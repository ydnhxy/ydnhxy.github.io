<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>hook | 彭先生的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="什么是 React HooksReact Hooks 是 React 16.7.0-alpha 版本推出的新特性，想尝试的同学安装此版本即可。 React Hooks 要解决的问题是状态共享，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。 这个状态指的是状态逻辑，所以称为状态逻辑复用会更恰当，因为只共享">
<meta property="og:type" content="article">
<meta property="og:title" content="hook">
<meta property="og:url" content="http://example.com/2020/12/27/hook/index.html">
<meta property="og:site_name" content="彭先生的个人博客">
<meta property="og:description" content="什么是 React HooksReact Hooks 是 React 16.7.0-alpha 版本推出的新特性，想尝试的同学安装此版本即可。 React Hooks 要解决的问题是状态共享，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。 这个状态指的是状态逻辑，所以称为状态逻辑复用会更恰当，因为只共享">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-12-27T12:44:37.000Z">
<meta property="article:modified_time" content="2020-12-27T12:57:13.770Z">
<meta property="article:author" content="彭博">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/scrollUp/image.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 5.3.0"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">彭先生的个人博客</div>
      
       <ul class="my-socials">
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/categories/life">生活</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">彭先生的个人博客</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="example.com">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/life">生活</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-hook" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/27/hook/" class="article-date">
  <time datetime="2020-12-27T12:44:37.000Z" itemprop="datePublished">2020-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      hook
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是-React-Hooks"><a href="#什么是-React-Hooks" class="headerlink" title="什么是 React Hooks"></a>什么是 React Hooks</h2><p>React Hooks 是 React <code>16.7.0-alpha</code> 版本推出的新特性，想尝试的同学安装此版本即可。</p>
<p><strong>React Hooks 要解决的问题是状态共享</strong>，是继 <a href="https://link.zhihu.com/?target=https://reactjs.org/docs/render-props.html">render-props</a> 和 <a href="https://link.zhihu.com/?target=https://reactjs.org/docs/higher-order-components.html">higher-order components</a> 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。</p>
<p>这个状态指的是状态逻辑，所以称为<strong>状态逻辑复用</strong>会更恰当，因为只共享数据处理逻辑，不会共享数据本身。</p>
<blockquote>
<p>不久前精读分享过的一篇 <a href="https://link.zhihu.com/?target=https://github.com/dt-fe/weekly/blob/master/75.%E7%B2%BE%E8%AF%BB%E3%80%8AEpitath%20%E6%BA%90%E7%A0%81%20-%20renderProps%20%E6%96%B0%E7%94%A8%E6%B3%95%E3%80%8B.md">Epitath 源码 - renderProps 新用法</a> 就是解决 JSX 嵌套问题，有了 React Hooks 之后，这个问题就被官方正式解决了。</p>
</blockquote>
<p>为了更快理解 React Hooks 是什么，先看笔者引用的下面一段 renderProps 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Toggle initial=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">      &#123;<span class="function">(<span class="params">&#123; on, toggle &#125;</span>) =&gt;</span> (</span><br><span class="line">        &lt;Button type=<span class="string">&quot;primary&quot;</span> onClick=&#123;toggle&#125;&gt; Open Modal &lt;/Button&gt;</span><br><span class="line">        &lt;Modal visible=&#123;on&#125; onOk=&#123;toggle&#125; onCancel=&#123;toggle&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/Toggle&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>恰巧，React Hooks 解决的也是这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [open, setOpen] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Button type=<span class="string">&quot;primary&quot;</span> onClick=&#123;<span class="function">() =&gt;</span> setOpen(<span class="literal">true</span>)&#125;&gt;</span><br><span class="line">        Open Modal</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">      &lt;Modal</span><br><span class="line">        visible=&#123;open&#125;</span><br><span class="line">        onOk=&#123;<span class="function">() =&gt;</span> setOpen(<span class="literal">false</span>)&#125;</span><br><span class="line">        onCancel=&#123;<span class="function">() =&gt;</span> setOpen(<span class="literal">false</span>)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，React Hooks 就像一个内置的打平 renderProps 库，我们可以随时创建一个值，与修改这个值的方法。看上去像 function 形式的 setState，其实这等价于依赖注入，与使用 setState 相比，<strong>这个组件是没有状态的</strong>。</p>
<h2 id="React-Hooks-的特点"><a href="#React-Hooks-的特点" class="headerlink" title="React Hooks 的特点"></a>React Hooks 的特点</h2><p>React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性：</p>
<ol>
<li>多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。</li>
<li>Hooks 可以引用其他 Hooks。</li>
<li>更容易将组件的 UI 与状态分离。</li>
</ol>
<p>利用 useEffect 代替一些生命周期</p>
<p>在 useState 位置附近，可以使用 useEffect 处理副作用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Clean up the subscription</span></span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>useEffect</code> 的代码既会在初始化时候执行，也会在后续每次 rerender 时执行，而返回值在析构时执行。这个更多带来的是便利，对比一下 React 版 G2 调用流程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span>&lt;<span class="title">Props</span>, <span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">  private chart: G2.Chart = <span class="literal">null</span>;</span><br><span class="line">  private rootDomRef: React.ReactInstance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rootDom = ReactDOM.findDOMNode(<span class="built_in">this</span>.rootDomRef) <span class="keyword">as</span> HTMLDivElement;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.chart = <span class="keyword">new</span> G2.Chart(&#123;</span><br><span class="line">      container: <span class="built_in">document</span>.getElementById(<span class="string">&quot;chart&quot;</span>),</span><br><span class="line">      forceFit: <span class="literal">true</span>,</span><br><span class="line">      height: <span class="number">300</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.freshChart(<span class="built_in">this</span>.props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps: Props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.freshChart(nextProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.chart.destroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">freshChart</span>(<span class="params">props: Props</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">this</span>.chart.render();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;ref</span> =&gt;</span> (this.rootDomRef = ref)&#125; /&gt;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 React Hooks 可以这么做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = React.useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> chart: G2.Chart = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!chart) &#123;</span><br><span class="line">      chart = <span class="keyword">new</span> G2.Chart(&#123;</span><br><span class="line">        container: ReactDOM.findDOMNode(ref.current) <span class="keyword">as</span> HTMLDivElement,</span><br><span class="line">        width: <span class="number">500</span>,</span><br><span class="line">        height: <span class="number">500</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    chart.render();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> chart.destroy();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到将细碎的代码片段结合成了一个完整的代码块，更维护。</p>
<p>现在介绍了 <code>useState</code> <code>useContext</code> <code>useEffect</code> <code>useRef</code> 等常用 hooks，更多可以查阅：<a href="https://link.zhihu.com/?target=https://reactjs.org/docs/hooks-reference.html">内置 Hooks</a>，相信不久的未来，这些 API 又会成为一套新的前端规范。</p>
<h2 id="React-Hooks-将带来什么变化"><a href="#React-Hooks-将带来什么变化" class="headerlink" title="React Hooks 将带来什么变化"></a>React Hooks 将带来什么变化</h2><h2 id="Hooks-带来的约定"><a href="#Hooks-带来的约定" class="headerlink" title="Hooks 带来的约定"></a>Hooks 带来的约定</h2><p>Hook 函数必须以 “use” 命名开头，因为这样才方便 eslint 做检查，防止用 condition 判断包裹 useHook 语句。</p>
<p>为什么不能用 condition 包裹 useHook 语句，详情可以见 <a href="https://link.zhihu.com/?target=https://reactjs.org/docs/hooks-rules.html%23explanation">官方文档</a>，这里简单介绍一下。</p>
<p>React Hooks 并不是通过 Proxy 或者 getters 实现的（具体可以看这篇文章 <a href="https://link.zhihu.com/?target=https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">React hooks: not magic, just arrays</a>），而是通过数组实现的，每次 <code>useState</code> 都会改变下标，如果 <code>useState</code>被包裹在 condition 中，那每次执行的下标就可能对不上，导致 <code>useState</code> 导出的 <code>setter</code> 更新错数据。</p>
<p>虽然有 <a href="https://link.zhihu.com/?target=https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a> 插件保驾护航，但这第一次将 “约定优先” 理念引入了 React 框架中，带来了前所未有的<strong>代码命名和顺序限制</strong>（函数命名遭到官方限制，JS 自由主义者也许会暴跳如雷），但带来的便利也是前所未有的（没有比 React Hooks 更好的状态共享方案了，约定带来提效，自由的代价就是回到 renderProps or HOC，各团队可以自行评估）。</p>
<p>笔者认为，React Hooks 的诞生，也许来自于这个灵感：“不如通过增加一些约定，彻底解决状态共享问题吧！”</p>
<blockquote>
<p>React 约定大于配置脚手架 <a href="https://link.zhihu.com/?target=https://github.com/zeit/next.js">nextjs</a> <a href="https://link.zhihu.com/?target=https://github.com/umijs/umi">umi</a> 以及笔者的 <a href="https://link.zhihu.com/?target=https://github.com/prijs/pri">pri</a> 都通过有 “约定路由” 的功能，大大降低了路由配置复杂度，<strong>那么 React Hooks 就像代码级别的约定</strong>，大大降低了代码复杂度。</p>
</blockquote>
<h2 id="状态与-UI-的界限会越来越清晰"><a href="#状态与-UI-的界限会越来越清晰" class="headerlink" title="状态与 UI 的界限会越来越清晰"></a>状态与 UI 的界限会越来越清晰</h2><p>因为 React Hooks 的特性，如果一个 Hook 不产生 UI，那么它可以永远被其他 Hook 封装，虽然允许有副作用，但是被包裹在 <code>useEffect</code> 里，总体来说还是挺函数式的。而 Hooks 要集中在 UI 函数顶部写，也很容易养成书写无状态 UI 组件的好习惯，践行 “状态与 UI 分开” 这个理念会更容易。</p>
<p>不过这个理念稍微有点蹩脚的地方，那就是 “状态” 到底是什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useCount();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道 <code>useCount</code> 算是无状态的，因为 React Hooks 本质就是 renderProps 或者 HOC 的另一种写法，换成 renderProps 就好理解了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Count&gt;&#123;<span class="function">(<span class="params">count, setCount</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;</span> <span class="attr">setCount</span>=<span class="string">&#123;setCount&#125;</span> /&gt;</span></span>&#125;&lt;/Count&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;props.count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 App 组件是无状态的，输出完全由输入（Props）决定。</p>
<p>那么有状态无 UI 的组件就是 <code>useCount</code> 了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> [count, setCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有状态的地方应该指 <code>useState(0)</code> 这句，不过这句和无状态 UI 组件 App 的 <code>useCount()</code> 很像，既然 React 把 <code>useCount</code> 成为自定义 Hook，那么 <code>useState</code> 就是官方 Hook，具有一样的定义，因此可以认为 <code>useCount</code> 是无状态的，<code>useState</code> 也是一层 renderProps，最终的状态其实是 <code>useState</code> 这个 React 内置的组件。</p>
<p>我们看 renderProps 嵌套的表达：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;UseState&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">count, setCount</span>) =&gt;</span> (</span><br><span class="line">    &lt;UseCount&gt;</span><br><span class="line">      &#123;<span class="string">&quot; &quot;</span>&#125;</span><br><span class="line">      &#123;<span class="comment">/**虽然是透传，但给 count 做了去重，不可谓没有作用 */</span>&#125;</span><br><span class="line">      &#123;<span class="function">(<span class="params">count, setCount</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;</span> <span class="attr">setCount</span>=<span class="string">&#123;setCount&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">    &lt;/UseCount&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/UseState&gt;</span><br></pre></td></tr></table></figure>
<p>能确定的是，App 一定有 UI，而上面两层父级组件一定没有 UI。为了最佳实践，我们尽量避免 App 自己维护状态，而其父级的 RenderProps 组件可以维护状态（也可以不维护状态，做个二传手）。因此可以考虑在 “有状态的组件没有渲染，有渲染的组件没有状态” 这句话后面加一句：没渲染的组件也可以没状态。</p>
<h2 id="React-Hooks-实践"><a href="#React-Hooks-实践" class="headerlink" title="React Hooks 实践"></a>React Hooks 实践</h2><p>通过上面的理解，你已经对 React Hooks 有了基本理解，也许你也看了 React Hooks 基本实现剖析（就是数组），但理解实现原理就可以用好了吗？学的是知识，而用的是技能，看别人的用法就像刷抖音一样（哇，饭还可以这样吃？），你总会有新的收获。</p>
<h2 id="DOM-副作用修改-监听"><a href="#DOM-副作用修改-监听" class="headerlink" title="DOM 副作用修改 / 监听"></a>DOM 副作用修改 / 监听</h2><p>做一个网页，总有一些看上去和组件关系不大的麻烦事，比如修改页面标题（切换页面记得改成默认标题）、监听页面大小变化（组件销毁记得取消监听）、断网时提示（一层层装饰器要堆成小山了）。而 React Hooks 特别擅长做这些事，造这种轮子，大小皆宜。</p>
<blockquote>
<p>由于 React Hooks 降低了高阶组件使用成本，那么一套生命周期才能完成的 “杂耍” 将变得非常简单。</p>
</blockquote>
<p>下面举几个例子：</p>
<h2 id="修改页面-title"><a href="#修改页面-title" class="headerlink" title="修改页面 title"></a>修改页面 title</h2><p>效果：在组件里调用 <code>useDocumentTitle</code> 函数即可设置页面标题，且切换页面时，页面标题重置为默认标题 “前端精读”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useDocumentTitle(<span class="string">&quot;个人中心&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>实现：直接用 <code>document.title</code> 赋值，不能再简单。在销毁时再次给一个默认标题即可，这个简单的函数可以抽象在项目工具函数里，每个页面组件都需要调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDocumentTitle</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="built_in">document</span>.title = title;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> (<span class="built_in">document</span>.title = <span class="string">&quot;前端精读&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    [title]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/lrnvnx866l">在线 Demo</a></p>
<h2 id="监听页面大小变化，网络是否断开"><a href="#监听页面大小变化，网络是否断开" class="headerlink" title="监听页面大小变化，网络是否断开"></a>监听页面大小变化，网络是否断开</h2><p>效果：在组件调用 <code>useWindowSize</code> 时，可以拿到页面大小，并且在浏览器缩放时自动触发组件更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> windowSize = useWindowSize();</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>页面高度：&#123;windowSize.innerWidth&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>实现：和标题思路基本一致，这次从 <code>window.innerHeight</code> 等 API 直接拿到页面宽高即可，注意此时可以用 <code>window.addEventListener(&#39;resize&#39;)</code> 监听页面大小变化，此时调用 <code>setValue</code>将会触发调用自身的 UI 组件 rerender，就是这么简单！</p>
<p>最后注意在销毁时，<code>removeEventListener</code> 注销监听。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    innerHeight: <span class="built_in">window</span>.innerHeight,</span><br><span class="line">    innerWidth: <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    outerHeight: <span class="built_in">window</span>.outerHeight,</span><br><span class="line">    outerWidth: <span class="built_in">window</span>.outerWidth</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useWindowSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [windowSize, setWindowSize] = useState(getSize());</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleResize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setWindowSize(getSize());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, handleResize);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">&quot;resize&quot;</span>, handleResize);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> windowSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/j2rz2mj83">在线 Demo</a></p>
<h2 id="动态注入-css"><a href="#动态注入-css" class="headerlink" title="动态注入 css"></a>动态注入 css</h2><p>效果：在页面注入一段 class，并且当组件销毁时，移除这个 class。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> className = useCss(&#123;</span><br><span class="line">  color: <span class="string">&quot;red&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span>Text.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>实现：可以看到，Hooks 方便的地方是在组件销毁时移除副作用，所以我们可以安心的利用 Hooks 做一些副作用。注入 css 自然不必说了，而销毁 css 只要找到注入的那段引用进行销毁即可，具体可以看这个 <a href="https://link.zhihu.com/?target=https://github.com/streamich/nano-css/blob/c21413ddbed233777886f7c9aa1375af8a221f7b/addon/pipe.js%23L51">代码片段</a>。</p>
<blockquote>
<p>DOM 副作用修改 / 监听场景有一些现成的库了，从名字上就能看出来用法：<a href="https://link.zhihu.com/?target=https://github.com/rehooks/document-visibility">document-visibility</a>、<a href="https://link.zhihu.com/?target=https://github.com/rehooks/network-status">network-status</a>、<a href="https://link.zhihu.com/?target=https://github.com/rehooks/online-status">online-status</a>、<a href="https://link.zhihu.com/?target=https://github.com/rehooks/window-scroll-position">window-scroll-position</a>、<a href="https://link.zhihu.com/?target=https://github.com/rehooks/window-size">window-size</a>、<a href="https://link.zhihu.com/?target=https://github.com/rehooks/document-title">document-title</a>。</p>
</blockquote>
<h2 id="组件辅助"><a href="#组件辅助" class="headerlink" title="组件辅助"></a>组件辅助</h2><p>Hooks 还可以增强组件能力，比如拿到并监听组件运行时宽高等。</p>
<h2 id="获取组件宽高"><a href="#获取组件宽高" class="headerlink" title="获取组件宽高"></a>获取组件宽高</h2><p>效果：通过调用 <code>useComponentSize</code> 拿到某个组件 ref 实例的宽高，并且在宽高变化时，rerender 并拿到最新的宽高。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = useRef(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">let</span> componentSize = useComponentSize(ref);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &#123;componentSize.width&#125;</span><br><span class="line">    &lt;textArea ref=&#123;ref&#125; /&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>实现：和 DOM 监听类似，这次换成了利用 <code>ResizeObserver</code> 对组件 ref 进行监听，同时在组件销毁时，销毁监听。</p>
<p>其本质还是监听一些副作用，但通过 ref 的传递，我们可以对组件粒度进行监听和操作了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  handleResize();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> resizeObserver = <span class="keyword">new</span> ResizeObserver(<span class="function">() =&gt;</span> handleResize());</span><br><span class="line">  resizeObserver.observe(ref.current);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resizeObserver.disconnect(ref.current);</span><br><span class="line">    resizeObserver = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/zqxp3l9yrm">在线 Demo</a>，对应组件 <a href="https://link.zhihu.com/?target=https://github.com/rehooks/component-size">component-size</a>。</p>
<h2 id="拿到组件-onChange-抛出的值"><a href="#拿到组件-onChange-抛出的值" class="headerlink" title="拿到组件 onChange 抛出的值"></a>拿到组件 onChange 抛出的值</h2><p>效果：通过 <code>useInputValue()</code> 拿到 Input 框当前用户输入的值，而不是手动监听 onChange 再腾一个 <code>otherInputValue</code> 和一个回调函数把这一堆逻辑写在无关的地方。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = useInputValue(<span class="string">&quot;Jamie&quot;</span>);</span><br><span class="line"><span class="comment">// name = &#123; value: &#x27;Jamie&#x27;, onChange: [Function] &#125;</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...name</span>&#125; /&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看到，这样不仅没有占用组件自己的 state，也不需要手写 onChange 回调函数进行处理，这些处理都压缩成了一行 use hook。</p>
<p>实现：读到这里应该大致可以猜到了，利用 <code>useState</code> 存储组件的值，并抛出 <code>value</code> 与 <code>onChange</code>，监听 <code>onChange</code> 并通过 <code>setValue</code> 修改 <code>value</code>, 就可以在每次 <code>onChange</code> 时触发调用组件的 rerender 了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useInputValue</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [value, setValue] = useState(initialValue);</span><br><span class="line">  <span class="keyword">let</span> onChange = useCallback(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    setValue(event.currentTarget.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value,</span><br><span class="line">    onChange</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，我们对组件增强时，<strong>组件的回调一般不需要销毁监听，而且仅需监听一次，这与 DOM 监听不同</strong>，因此大部分场景，我们需要利用 <code>useCallback</code> 包裹，并传一个空数组，来保证永远只监听一次，而且不需要在组件销毁时注销这个 callback。</p>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/0xlk250l5l">在线 Demo</a>，对应组件 <a href="https://link.zhihu.com/?target=https://github.com/rehooks/input-value">input-value</a>。</p>
<h2 id="做动画"><a href="#做动画" class="headerlink" title="做动画"></a>做动画</h2><p>利用 React Hooks 做动画，一般是拿到一些具有弹性变化的值，我们可以将值赋给进度条之类的组件，这样其进度变化就符合某种动画曲线。</p>
<h2 id="在某个时间段内获取-0-1-之间的值"><a href="#在某个时间段内获取-0-1-之间的值" class="headerlink" title="在某个时间段内获取 0-1 之间的值"></a>在某个时间段内获取 0-1 之间的值</h2><p>这个是动画最基本的概念，某个时间内拿到一个线性增长的值。</p>
<p>效果：通过 <code>useRaf(t)</code> 拿到 t 毫秒内不断刷新的 0-1 之间的数字，期间组件会不断刷新，但刷新频率由 requestAnimationFrame 控制（不会卡顿 UI）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useRaf(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>实现：写起来比较冗长，这里简单描述一下。利用 <code>requestAnimationFrame</code> 在给定时间内给出 0-1 之间的值，那每次刷新时，只要判断当前刷新的时间点占总时间的比例是多少，然后做分母，分子是 1 即可。</p>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/n745x9pyy4">在线 Demo</a>，对应组件 <a href="https://link.zhihu.com/?target=https://github.com/streamich/react-use/blob/master/docs/useRaf.md">use-raf</a>。</p>
<h2 id="弹性动画"><a href="#弹性动画" class="headerlink" title="弹性动画"></a>弹性动画</h2><p>效果：通过 <code>useSpring</code> 拿到动画值，组件以固定频率刷新，而这个动画值以弹性函数进行增减。</p>
<p>实际调用方式一般是，先通过 <code>useState</code> 拿到一个值，再通过动画函数包住这个值，这样组件就会从原本的刷新一次，变成刷新 N 次，拿到的值也随着动画函数的规则变化，最后这个值会稳定到最终的输入值（如例子中的 <code>50</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [target, setTarget] = useState(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">const</span> value = useSpring(target);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setTarget(100)&#125;&gt;&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>实现：为了实现动画效果，需要依赖 <code>rebound</code> 库，它可以实现将一个目标值拆解为符合弹性动画函数过程的功能，那我们需要利用 React Hooks 做的就是在第一次接收到目标值是，调用 <code>spring.setEndValue</code> 来触发动画事件，并在 <code>useEffect</code> 里做一次性监听，再值变时重新 <code>setValue</code> 即可。</p>
<p>最神奇的 <code>setTarget</code> 联动 <code>useSpring</code> 重新计算弹性动画部分，是通过 <code>useEffect</code> 第二个参数实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">useEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (spring) &#123;</span><br><span class="line">      spring.setEndValue(targetValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  [targetValue]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>也就是当目标值变化后，才会进行新的一轮 rerender，所以 <code>useSpring</code> 并不需要监听调用处的 <code>setTarget</code>，它只需要监听 <code>target</code> 的变化即可，而巧妙利用 <code>useEffect</code> 的第二个参数可以事半功倍。</p>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/yq0moqo8mv">在线 Demo</a></p>
<h2 id="Tween-动画"><a href="#Tween-动画" class="headerlink" title="Tween 动画"></a>Tween 动画</h2><p>明白了弹性动画原理，Tween 动画就更简单了。</p>
<p>效果：通过 <code>useTween</code> 拿到一个从 0 变化到 1 的值，这个值的动画曲线是 <code>tween</code>。可以看到，由于取值范围是固定的，所以我们不需要给初始值了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useTween();</span><br></pre></td></tr></table></figure>
<p>实现：通过 <code>useRaf</code> 拿到一个线性增长的值（区间也是 0 ～ 1），再通过 <code>easing</code> 库将其映射到 0 ～ 1 到值即可。这里用到了 hook 调用 hook 的联动（通过 <code>useRaf</code> 驱动 <code>useTween</code>），还可以在其他地方举一反三。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn: Easing = easing[easingName];</span><br><span class="line"><span class="keyword">const</span> t = useRaf(ms, delay);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fn(t);</span><br></pre></td></tr></table></figure>
<h2 id="发请求"><a href="#发请求" class="headerlink" title="发请求"></a>发请求</h2><p>利用 Hooks，可以将任意请求 Promise 封装为带有标准状态的对象：loading、error、result。</p>
<h2 id="通用-Http-封装"><a href="#通用-Http-封装" class="headerlink" title="通用 Http 封装"></a>通用 Http 封装</h2><p>效果：通过 <code>useAsync</code> 将一个 Promise 拆解为 loading、error、result 三个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; loading, error, result &#125; = useAsync(fetchUser, [id]);</span><br></pre></td></tr></table></figure>
<p>实现：在 Promise 的初期设置 loading，结束后设置 result，如果出错则设置 error，这里可以将请求对象包装成 <code>useAsyncState</code> 来处理，这里就不放出来了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useAsync</span>(<span class="params">asyncFunction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> asyncState = useAsyncState(options);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = asyncFunction();</span><br><span class="line">    asyncState.setLoading();</span><br><span class="line">    promise.then(</span><br><span class="line">      result =&gt; asyncState.setResult(result);,</span><br><span class="line">      error =&gt; asyncState.setError(error);</span><br><span class="line">    );</span><br><span class="line">  &#125;, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码可以参考 <a href="https://link.zhihu.com/?target=https://github.com/slorber/react-async-hook/blob/master/src/index.js">react-async-hook</a>，这个功能建议仅了解原理，具体实现因为有一些边界情况需要考虑，比如组件 isMounted 后才能相应请求结果。</p>
<h2 id="Request-Service"><a href="#Request-Service" class="headerlink" title="Request Service"></a>Request Service</h2><p>业务层一般会抽象一个 <code>request service</code> 做统一取数的抽象（比如统一 url，或者可以统一换 socket 实现等等）。假如以前比较 low 的做法是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// setState: 改 isLoading state</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> fetchUser()</span><br><span class="line">    <span class="comment">// setState: 改 isLoading、error、data</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// setState: 改 isLoading、error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后来把请求放在 redux 里，通过 connect 注入的方式会稍微有些改观：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Connect(...)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  public <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.fetchUser()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this.props.userData.isLoading | error | data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后会发现还是 Hooks 简洁明了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; isLoading, error, data &#125; = useFetchUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>useFetchUser</code> 利用上面封装的 <code>useAsync</code> 可以很容易编写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchUser = <span class="function"><span class="params">id</span> =&gt;</span></span><br><span class="line">  fetch(<span class="string">`xxx`</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.status !== <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;bad status = &quot;</span> + result.status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.json();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFetchUser</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> asyncFetchUser = useAsync(fetchUser, id);</span><br><span class="line">  <span class="keyword">return</span> asyncUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="填表单"><a href="#填表单" class="headerlink" title="填表单"></a>填表单</h2><p>React Hooks 特别适合做表单，尤其是 <a href="https://link.zhihu.com/?target=https://ant.design/components/form-cn/">antd form</a> 如果支持 Hooks 版，那用起来会方便许多：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; getFieldDecorator &#125; = useAntdForm();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Form onSubmit=&#123;<span class="built_in">this</span>.handleSubmit&#125; className=<span class="string">&quot;login-form&quot;</span>&gt;</span><br><span class="line">      &lt;FormItem&gt;</span><br><span class="line">        &#123;getFieldDecorator(<span class="string">&quot;userName&quot;</span>, &#123;</span><br><span class="line">          rules: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&quot;Please input your username!&quot;</span> &#125;]</span><br><span class="line">        &#125;)(</span><br><span class="line">          &lt;Input</span><br><span class="line">            prefix=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &quot;<span class="attr">rgba</span>(<span class="attr">0</span>,<span class="attr">0</span>,<span class="attr">0</span>,<span class="attr">.25</span>)&quot; &#125;&#125; /&gt;</span></span>&#125;</span><br><span class="line">            placeholder=<span class="string">&quot;Username&quot;</span></span><br><span class="line">          /&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/FormItem&gt;</span><br><span class="line">      &lt;FormItem&gt;</span><br><span class="line">        &lt;Button type=<span class="string">&quot;primary&quot;</span> htmlType=<span class="string">&quot;submit&quot;</span> className=<span class="string">&quot;login-form-button&quot;</span>&gt;</span><br><span class="line">          Log <span class="keyword">in</span></span><br><span class="line">        &lt;/Button&gt;</span><br><span class="line">        Or &lt;a href=<span class="string">&quot;&quot;</span>&gt;register now!&lt;/a&gt;</span><br><span class="line">      &lt;/FormItem&gt;</span><br><span class="line">    &lt;/Form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过虽然如此，<code>getFieldDecorator</code> 还是基于 RenderProps 思路的，彻底的 Hooks 思路是利用之前说的 <strong>组件辅助方式，提供一个组件方法集，用解构方式传给组件</strong>。</p>
<h2 id="模拟生命周期"><a href="#模拟生命周期" class="headerlink" title="模拟生命周期"></a>模拟生命周期</h2><p>有的时候 React15 的 API 还是挺有用的，利用 React Hooks 几乎可以模拟出全套。</p>
<h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><p>效果：通过 <code>useMount</code> 拿到 mount 周期才执行的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useMount(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// quite similar to `componentDidMount`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实现：<code>componentDidMount</code> 等价于 <code>useEffect</code> 的回调（仅执行一次时），因此直接把回调函数抛出来即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> <span class="keyword">void</span> fn(), []);</span><br></pre></td></tr></table></figure>
<h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h2><p>效果：通过 <code>useUnmount</code> 拿到 unmount 周期才执行的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useUnmount(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// quite similar to `componentWillUnmount`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实现：<code>componentWillUnmount</code> 等价于 <code>useEffect</code> 的回调函数返回值（仅执行一次时），因此直接把回调函数返回值抛出来即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> fn, []);</span><br></pre></td></tr></table></figure>
<h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><p>效果：通过 <code>useUpdate</code> 拿到 didUpdate 周期才执行的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useUpdate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// quite similar to `componentDidUpdate`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实现：<code>componentDidUpdate</code> 等价于 <code>useMount</code> 的逻辑每次执行，除了初始化第一次。因此采用 mouting flag（判断初始状态）+ 不加限制参数确保每次 rerender 都会执行即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mounting = useRef(<span class="literal">true</span>);</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (mounting.current) &#123;</span><br><span class="line">    mounting.current = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Force-Update"><a href="#Force-Update" class="headerlink" title="Force Update"></a>Force Update</h2><p>效果：这个最有意思了，我希望拿到一个函数 <code>update</code>，每次调用就强制刷新当前组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> update = useUpdate();</span><br></pre></td></tr></table></figure>
<p>实现：我们知道 <code>useState</code> 下标为 1 的项是用来更新数据的，而且就算数据没有变化，调用了也会刷新组件，所以我们可以把返回一个没有修改数值的 <code>setValue</code>，这样它的功能就仅剩下刷新组件了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useUpdate = <span class="function">() =&gt;</span> useState(<span class="number">0</span>)[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于 <code>getSnapshotBeforeUpdate</code>, <code>getDerivedStateFromError</code>, <code>componentDidCatch</code> 目前 Hooks 是无法模拟的。</p>
</blockquote>
<h2 id="isMounted"><a href="#isMounted" class="headerlink" title="isMounted"></a>isMounted</h2><p>很久以前 React 是提供过这个 API 的，后来移除了，原因是可以通过 <code>componentWillMount</code> 和 <code>componentWillUnmount</code> 推导。自从有了 React Hooks，支持 isMount 简直是分分钟的事。</p>
<p>效果：通过 <code>useIsMounted</code> 拿到 <code>isMounted</code> 状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isMounted = useIsMounted();</span><br></pre></td></tr></table></figure>
<p>实现：看到这里的话，应该已经很熟悉这个套路了，<code>useEffect</code> 第一次调用时赋值为 true，组件销毁时返回 false，注意这里可以加第二个参数为空数组来优化性能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [isMount, setIsMount] = useState(<span class="literal">false</span>);</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isMount) &#123;</span><br><span class="line">    setIsMount(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> setIsMount(<span class="literal">false</span>);</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="keyword">return</span> isMount;</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/5zwr1l1o1n">在线 Demo</a></p>
<h2 id="存数据"><a href="#存数据" class="headerlink" title="存数据"></a>存数据</h2><p>上一篇提到过 React Hooks 内置的 <code>useReducer</code> 可以模拟 Redux 的 reducer 行为，那唯一需要补充的就是将数据持久化。我们考虑最小实现，也就是全局 Store + Provider 部分。</p>
<h2 id="全局-Store"><a href="#全局-Store" class="headerlink" title="全局 Store"></a>全局 Store</h2><p>效果：通过 <code>createStore</code> 创建一个全局 Store，再通过 <code>StoreProvider</code> 将 <code>store</code> 注入到子组件的 <code>context</code>中，最终通过两个 Hooks 进行获取与操作：<code>useStore</code> 与 <code>useAction</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line">  user: &#123;</span><br><span class="line">    name: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    setName: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> &#123;</span><br><span class="line">      state.name = payload;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;StoreProvider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;YourApp /&gt;</span><br><span class="line">  &lt;/StoreProvider&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">YourApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> userName = useStore(<span class="function"><span class="params">state</span> =&gt;</span> state.user.name);</span><br><span class="line">  <span class="keyword">const</span> setName = userAction(<span class="function"><span class="params">dispatch</span> =&gt;</span> dispatch.user.setName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现：这个例子的实现可以单独拎出一篇文章了，所以笔者从存数据的角度剖析一下 <code>StoreProvider</code> 的实现。</p>
<p>对，Hooks 并不解决 Provider 的问题，所以全局状态必须有 Provider，但这个 Provider 可以利用 React 内置的 <code>createContext</code> 简单搞定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> StoreContext = createContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StoreProvider = <span class="function">(<span class="params">&#123; children, store &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;StoreContext.Provider value=&#123;store&#125;&gt;&#123;children&#125;&lt;/StoreContext.Provider&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>剩下就是 <code>useStore</code> 怎么取到持久化 Store 的问题了，这里利用 <code>useContext</code> 和刚才创建的 Context 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = useContext(StoreContext);</span><br><span class="line"><span class="keyword">return</span> store;</span><br></pre></td></tr></table></figure>
<p>更多源码可以参考 <a href="https://link.zhihu.com/?target=https://github.com/ctrlplusb/easy-peasy">easy-peasy</a>，这个库基于 redux 编写，提供了一套 Hooks API。</p>
<h2 id="封装原有库"><a href="#封装原有库" class="headerlink" title="封装原有库"></a>封装原有库</h2><p>是不是 React Hooks 出现后，所有的库都要重写一次？当然不是，我们看看其他库如何做改造。</p>
<h2 id="RenderProps-to-Hooks"><a href="#RenderProps-to-Hooks" class="headerlink" title="RenderProps to Hooks"></a>RenderProps to Hooks</h2><p>这里拿 <a href="https://link.zhihu.com/?target=https://github.com/renatorib/react-powerplug">react-powerplug</a> 举例。</p>
<p>比如有一个 renderProps 库，希望改造成 Hooks 的用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Toggle &#125; <span class="keyword">from</span> <span class="string">&#x27;react-powerplug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Toggle initial=&#123;<span class="literal">true</span>&#125;&gt;</span><br><span class="line">      &#123;<span class="function">(<span class="params">&#123; on, toggle &#125;</span>) =&gt;</span> (</span><br><span class="line">        &lt;Checkbox checked=&#123;on&#125; onChange=&#123;toggle&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/Toggle&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">↓ ↓ ↓ ↓ ↓ ↓</span><br><span class="line"><span class="keyword">import</span> &#123; useToggle &#125; <span class="keyword">from</span> <span class="string">&#x27;react-powerhooks&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [on, toggle] = useToggle()</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Checkbox</span> <span class="attr">checked</span>=<span class="string">&#123;on&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;toggle&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：假如我是 <code>react-powerplug</code> 的维护者，怎么样最小成本支持 React Hook? 说实话这个没办法一步做到，但可以通过两步实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Toggle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这是 Toggle 的源码</span></span><br><span class="line">  <span class="comment">// balabalabala..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = wrap(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第一步：包 wrap</span></span><br><span class="line">  <span class="keyword">const</span> [on, toggle] = useRenderProps(Toggle); <span class="comment">// 第二步：包 useRenderProps</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实现：首先解释一下为什么要包两层，首先 Hooks 必须遵循 React 的规范，我们必须写一个 <code>useRenderProps</code> 函数以符合 Hooks 的格式，<strong>那问题是如何拿到 Toggle 给 render 的 <code>on</code> 与 <code>toggle</code>？</strong>正常方式应该拿不到，所以退而求其次，将 <code>useRenderProps</code> 拿到的 Toggle 传给 <code>wrap</code>，<strong>让</strong> <code>**wrap**</code> <strong>构造 RenderProps 执行环境拿到</strong> <code>**on**</code> <strong>与</strong> <code>**toggle**</code> <strong>后，调用<code>useRenderProps</code>**</strong>内部的** <code>**setArgs**</code> <strong>函数，让</strong> <code>**const [on, toggle] = useRenderProps(Toggle)**</code> <strong>实现曲线救国。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrappers = []; <span class="comment">// 全局存储 wrappers</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useRenderProps = <span class="function">(<span class="params">WrapperComponent, wrapperProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [args, setArgs] = useState([]);</span><br><span class="line">  <span class="keyword">const</span> ref = useRef(&#123;&#125;);</span><br><span class="line">  <span class="keyword">if</span> (!ref.current.initialized) &#123;</span><br><span class="line">    wrappers.push(&#123;</span><br><span class="line">      WrapperComponent,</span><br><span class="line">      wrapperProps,</span><br><span class="line">      setArgs</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ref.current.initialized = <span class="literal">true</span>;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> args; <span class="comment">// 通过下面 wrap 调用 setArgs 获取值。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于 <code>useRenderProps</code> 会先于 <code>wrap</code> 执行，所以 wrappers 会先拿到 Toggle，<code>wrap</code> 执行时直接调用 <code>wrappers.pop()</code> 即可拿到 Toggle 对象。然后构造出 RenderProps 的执行环境即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> wrap = <span class="function"><span class="params">FunctionComponent</span> =&gt;</span> <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> element = FunctionComponent(props);</span><br><span class="line">  <span class="keyword">const</span> ref = useRef(&#123; <span class="attr">wrapper</span>: wrappers.pop() &#125;); <span class="comment">// 拿到 useRenderProps 提供的 Toggle</span></span><br><span class="line">  <span class="keyword">const</span> &#123; WrapperComponent, wrapperProps &#125; = ref.current.wrapper;</span><br><span class="line">  <span class="keyword">return</span> createElement(WrapperComponent, wrapperProps, <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// WrapperComponent =&gt; Toggle，这一步是在构造 RenderProps 执行环境</span></span><br><span class="line">    <span class="keyword">if</span> (!ref.current.processed) &#123;</span><br><span class="line">      ref.current.wrapper.setArgs(args); <span class="comment">// 拿到 on、toggle 后，通过 setArgs 传给上面的 args。</span></span><br><span class="line">      ref.current.processed = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.current.processed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上实现方案参考 <a href="https://link.zhihu.com/?target=https://github.com/dai-shi/react-hooks-render-props">react-hooks-render-props</a>，有需求要可以拿过来直接用，不过实现思路可以参考，作者的脑洞挺大。</p>
<h2 id="Hooks-to-RenderProps"><a href="#Hooks-to-RenderProps" class="headerlink" title="Hooks to RenderProps"></a>Hooks to RenderProps</h2><p>好吧，如果希望 Hooks 支持 RenderProps，那一定是希望同时支持这两套语法。</p>
<p>效果：一套代码同时支持 Hooks 和 RenderProps。</p>
<p>实现：其实 Hooks 封装为 RenderProps 最方便，因此我们使用 Hooks 写核心的代码，假设我们写一个最简单的 <code>Toggle</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useToggle = <span class="function"><span class="params">initialValue</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [on, setOn] = useState(initialValue);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    on,</span><br><span class="line">    toggle: <span class="function">() =&gt;</span> setOn(!on)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/ppvrpnz80m">在线 Demo</a></p>
<p>然后通过 <code>render-props</code> 这个库可以轻松封装出 RenderProps 组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Toggle = <span class="function">(<span class="params">&#123; initialValue, children, render = children &#125;</span>) =&gt;</span></span><br><span class="line">  renderProps(render, useToggle(initialValue));</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/249n3n4r30">在线 Demo</a></p>
<p>其实 <code>renderProps</code> 这个组件的第二个参数，在 Class 形式 React 组件时，接收的是 <code>this.state</code>，现在我们改成 <code>useToggle</code> 返回的对象，也可以理解为 <code>state</code>，利用 Hooks 机制驱动 Toggle 组件 rerender，从而让子组件 rerender。</p>
<h2 id="封装原本对-setState-增强的库"><a href="#封装原本对-setState-增强的库" class="headerlink" title="封装原本对 setState 增强的库"></a>封装原本对 setState 增强的库</h2><p>Hooks 也特别适合封装原本就作用于 setState 的库，比如 <a href="https://link.zhihu.com/?target=https://github.com/mweststrate/immer">immer</a>。</p>
<p><code>useState</code> 虽然不是 <code>setState</code>，但却可以理解为控制高阶组件的 <code>setState</code>，我们完全可以封装一个自定义的 <code>useState</code>，然后内置对 <code>setState</code> 的优化。</p>
<p>比如 immer 的语法是通过 <code>produce</code> 包装，将 mutable 代码通过 Proxy 代理为 immutable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nextState = produce(baseState, <span class="function"><span class="params">draftState</span> =&gt;</span> &#123;</span><br><span class="line">  draftState.push(&#123; <span class="attr">todo</span>: <span class="string">&quot;Tweet about it&quot;</span> &#125;);</span><br><span class="line">  draftState[<span class="number">1</span>].done = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那这个 <code>produce</code> 就可以通过封装一个 <code>useImmer</code> 来隐藏掉：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useImmer</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [val, updateValue] = React.useState(initialValue);</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    val,</span><br><span class="line">    updater =&gt; &#123;</span><br><span class="line">      updateValue(produce(updater));</span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [value, setValue] = useImmer(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">value(<span class="function"><span class="params">obj</span> =&gt;</span> (obj.a = <span class="number">2</span>)); <span class="comment">// immutable</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>把 React Hooks 当作更便捷的 RenderProps 去用吧，虽然写法看上去是内部维护了一个状态，但其实等价于注入、Connect、HOC、或者 renderProps，那么如此一来，使用 renderProps 的门槛会大大降低，因为 Hooks 用起来实在是太方便了，我们可以抽象大量 Custom Hooks，让代码更加 FP，同时也不会增加嵌套层级。</p>
<p>转载自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50597236">https://zhuanlan.zhihu.com/p/50597236</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/12/27/hook/" data-id="ckj750wwt0002ckvx5sli6f5f" class="article-share-link">Share</a>
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/12/25/%E4%BB%80%E4%B9%88%E6%98%AFBFC/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">什么是BFC</div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 彭博<br>
      Theme <a href="https://github.com/henryhuang/oishi" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories/life" class="mobile-nav-link">生活</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/jquery.scrollUp.min.js"></script>


<script src="/js/jquery.transform.js"></script>


<script src="/js/menu.js"></script>



<script src="/js/script.js"></script>


<script src="/js/scrollUp.js"></script>


  </div>
</body>
</html>