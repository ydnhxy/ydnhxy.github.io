<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>彭先生的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="彭先生的个人博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="彭先生的个人博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="彭博">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/scrollUp/image.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 5.3.0"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">彭先生的个人博客</div>
      
       <ul class="my-socials">
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">彭先生的个人博客</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="example.com">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main">
  

    
    <article id="javascript-严格模式" class="article article-type-javascript" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/31/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-12-31T00:47:44.000Z" itemprop="datePublished">2020-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/31/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/">严格模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>一、概述</strong></p>
<p>除了正常运行模式，ECMAscript 5添加了第二种运行模式：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/Strict_mode">“严格模式”</a>（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。</p>
<p>设立”严格模式”的目的，主要有以下几个：</p>
<blockquote>
<p>　　- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</p>
<p>　　- 消除代码运行的一些不安全之处，保证代码运行的安全；</p>
<p>　　- 提高编译器效率，增加运行速度；</p>
<p>　　- 为未来新版本的Javascript做好铺垫。</p>
</blockquote>
<p>“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经<a target="_blank" rel="noopener" href="http://kangax.github.com/es5-compat-table">支持</a>它，许多大项目已经开始全面拥抱它。</p>
<p>另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。</p>
<p><strong>二、进入标志</strong></p>
<p>进入”严格模式”的标志，是下面这行语句：</p>
<blockquote>
<p>　　“use strict”;</p>
</blockquote>
<p>老版本的浏览器会把它当作一行普通字符串，加以忽略。</p>
<p><strong>3.1 针对整个脚本文件</strong></p>
<p>将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。</p>
<p>(严格地说，只要前面不是产生实际运行结果的语句，”use strict”可以不在第一行，比如直接跟在一个空的分号后面。)</p>
<blockquote>
<p>　　<script>　　　　"use strict";　　　　console.log("这是严格模式。");　　</script></p>
<p>　　<script>　　　　console.log("这是正常模式。");kly, it's almost 2 years ago now. I can admit it now - I run it on my school's network that has about 50 computers.　　</script></p>
</blockquote>
<p>上面的代码表示，一个网页中依次有两段Javascript代码。前一个script标签是严格模式，后一个不是。</p>
<p><strong>3.2 针对单个函数</strong></p>
<p>将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行。</p>
<blockquote>
<p>　　function strict(){<br>　　　　“use strict”;<br>　　　　return “这是严格模式。”;<br>　　}</p>
<p>　　function notStrict() {<br>　　　　return “这是正常模式。”;<br>　　}</p>
</blockquote>
<p><strong>3.3 脚本文件的变通写法</strong></p>
<p>因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。</p>
<blockquote>
<p>　　(function (){</p>
<p>　　　　“use strict”;</p>
<p>　　　　// some code here</p>
<p>　　 })();</p>
</blockquote>
<p><strong>四、语法和行为改变</strong></p>
<p>严格模式对Javascript的语法和行为，都做了一些改变。</p>
<p><strong>4.1 全局变量显式声明</strong></p>
<p>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p>
<blockquote>
<p>“use strict”;</p>
<p>　　v = 1; // 报错，v未声明</p>
<p>　　for(i = 0; i &lt; 2; i++) { // 报错，i未声明<br>　　}</p>
</blockquote>
<p>因此，严格模式下，变量都必须先用var命令声明，然后再使用。</p>
<p><strong>4.2 静态绑定</strong></p>
<p>Javascript语言的一个特点，就是允许”动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。</p>
<p>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。</p>
<p>具体来说，涉及以下几个方面。</p>
<p><strong>（1）禁止使用with语句</strong></p>
<p>因为with语句无法在编译时就确定，属性到底归属哪个对象。</p>
<blockquote>
<p>　　“use strict”;</p>
<p>　　var v = 1;</p>
<p>　　with (o){ // 语法错误<br>　　　　v = 2;<br>　　}</p>
</blockquote>
<p><strong>（2）创设eval作用域</strong></p>
<p>正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。</p>
<p>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。</p>
<blockquote>
<p>　　“use strict”;</p>
<p>　　var x = 2;</p>
<p>　　console.info(eval(“var x = 5; x”)); // 5</p>
<p>　　console.info(x); // 2</p>
</blockquote>
<p><strong>4.3 增强的安全措施</strong></p>
<p><strong>（1）禁止this关键字指向全局对象</strong></p>
<blockquote>
<p>　　function f(){<br>　　　　return !this;<br>　　}<br>　　// 返回false，因为”this”指向全局对象，”!this”就是false</p>
<p>　　function f(){<br>　　　　“use strict”;<br>　　　　return !this;<br>　　}<br>　　// 返回true，因为严格模式下，this的值为undefined，所以”!this”为true。</p>
</blockquote>
<p>因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。</p>
<blockquote>
<p>　　function f(){</p>
<p>　　　　“use strict”;</p>
<p>　　　　this.a = 1;</p>
<p>　　};</p>
<p>　　f();// 报错，this未定义</p>
</blockquote>
<p><strong>（2）禁止在函数内部遍历调用栈</strong></p>
<blockquote>
<p>　　function f1(){</p>
<p>　　　　“use strict”;</p>
<p>　　　　f1.caller; // 报错</p>
<p>　　　　f1.arguments; // 报错</p>
<p>　　}</p>
<p>　　f1();</p>
</blockquote>
<p><strong>4.4 禁止删除变量</strong></p>
<p>严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。</p>
<blockquote>
<p>　　“use strict”;</p>
<p>　　var x;</p>
<p>　　delete x; // 语法错误</p>
<p>　　var o = Object.create(null, {‘x’: {<br>　　　　　　value: 1,<br>　　　　　　configurable: true<br>　　}});</p>
<p>　　delete o.x; // 删除成功</p>
</blockquote>
<p><strong>4.5 显式报错</strong></p>
<p>正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。</p>
<blockquote>
<p>　　“use strict”;</p>
<p>　　var o = {};</p>
<p>　　Object.defineProperty(o, “v”, { value: 1, writable: false });</p>
<p>　　o.v = 2; // 报错</p>
</blockquote>
<p>严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。</p>
<blockquote>
<p>　　“use strict”;</p>
<p>　　var o = {</p>
<p>　　　　get v() { return 1; }</p>
<p>　　};</p>
<p>　　o.v = 2; // 报错</p>
</blockquote>
<p>严格模式下，对禁止扩展的对象添加新属性，会报错。</p>
<blockquote>
<p>　　“use strict”;</p>
<p>　　var o = {};</p>
<p>　　Object.preventExtensions(o);</p>
<p>　　o.v = 1; // 报错</p>
</blockquote>
<p>严格模式下，删除一个不可删除的属性，会报错。</p>
<blockquote>
<p>　　“use strict”;</p>
<p>　　delete Object.prototype; // 报错</p>
</blockquote>
<p><strong>4.6 重名错误</strong></p>
<p>严格模式新增了一些语法错误。</p>
<p><strong>（1）对象不能有重名的属性</strong></p>
<p>正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。</p>
<blockquote>
<p>　　“use strict”;</p>
<p>　　var o = {<br>　　　　p: 1,<br>　　　　p: 2<br>　　}; // 语法错误</p>
</blockquote>
<p><strong>（2）函数不能有重名的参数</strong></p>
<p>正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。</p>
<blockquote>
<p>　　“use strict”;</p>
<p>　　function f(a, a, b) { // 语法错误</p>
<p>　　　　return ;</p>
<p>　　}</p>
</blockquote>
<p><strong>4.7 禁止八进制表示法</strong></p>
<p>正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。</p>
<blockquote>
<p>　　“use strict”;</p>
<p>　　var n = 0100; // 语法错误</p>
</blockquote>
<p><strong>4.8 arguments对象的限制</strong></p>
<p>arguments是函数的参数对象，严格模式对它的使用做了限制。</p>
<p><strong>（1）不允许对arguments赋值</strong></p>
<blockquote>
<p>　　“use strict”;</p>
<p>　　arguments++; // 语法错误</p>
<p>　　var obj = { set p(arguments) { } }; // 语法错误</p>
<p>　　try { } catch (arguments) { } // 语法错误</p>
<p>　　function arguments() { } // 语法错误</p>
<p>　　var f = new Function(“arguments”, “‘use strict’; return 17;”); // 语法错误</p>
</blockquote>
<p><strong>（2）arguments不再追踪参数的变化</strong></p>
<blockquote>
<p>　　function f(a) {</p>
<p>　　　　a = 2;</p>
<p>　　　　return [a, arguments[0]];</p>
<p>　　}</p>
<p>　　f(1); // 正常模式为[2,2]</p>
<p>　　function f(a) {</p>
<p>　　　　“use strict”;</p>
<p>　　　　a = 2;</p>
<p>　　　　return [a, arguments[0]];</p>
<p>　　}</p>
<p>　　f(1); // 严格模式为[2,1]</p>
</blockquote>
<p><strong>（3）禁止使用arguments.callee</strong></p>
<p>这意味着，你无法在匿名函数内部调用自身了。</p>
<blockquote>
<p>　　“use strict”;</p>
<p>　　var f = function() { return arguments.callee; };</p>
<p>　　f(); // 报错</p>
</blockquote>
<p><strong>4.9 函数必须声明在顶层</strong></p>
<p>将来Javascript的新版本会引入”块级作用域”。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。</p>
<blockquote>
<p>　　“use strict”;</p>
<p>　　if (true) {</p>
<p>　　　　function f() { } // 语法错误</p>
<p>　　}</p>
<p>　　for (var i = 0; i &lt; 5; i++) {</p>
<p>　　　　function f2() { } // 语法错误</p>
<p>　　}</p>
</blockquote>
<p><strong>4.10 保留字</strong></p>
<p>为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。</p>
<p>使用这些词作为变量名将会报错。</p>
<blockquote>
<p>　　function package(protected) { // 语法错误</p>
<p>　　　　“use strict”;</p>
<p>　　　　var implements; // 语法错误</p>
<p>　　}</p>
</blockquote>
<p>此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。</p>
<p><strong>五、参考链接</strong></p>
<p>- MDN, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/Strict_mode">Strict mode</a><br>- Dr. Axel Rauschmayer，<a target="_blank" rel="noopener" href="http://www.2ality.com/2011/01/javascripts-strict-mode-summary.html">JavaScript’s strict mode: a summary</a><br>- Douglas Crockford, <a target="_blank" rel="noopener" href="http://java-script.limewebs.com/strictMode/test_hosted.html">Strict Mode Is Coming To Town</a></p>
<p>（完）</p>
<p>转载自 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html">http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/12/31/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/" data-id="ckmvs5ua30003fsvxb9qqhu5v" class="article-share-link">Share</a>
      

      
    </footer>
  </div>
  
</article>


    
  

    
    <article id="post-TypeScript笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/29/TypeScript%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-12-29T11:51:10.000Z" itemprop="datePublished">2020-12-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/29/TypeScript%E7%AC%94%E8%AE%B0/">TypeScript笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript-与-TypeScript-的区别"><a href="#JavaScript-与-TypeScript-的区别" class="headerlink" title="JavaScript 与 TypeScript 的区别"></a>JavaScript 与 TypeScript 的区别</h2><p>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。<br>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。</p>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: boolean = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: number = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binaryLiteral: number = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octalLiteral: number = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>支持单引号(‘)双引号(“)反引号(`)用${str}嵌入的表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: string = <span class="string">&quot;bob&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> name: string = <span class="string">`Gene`</span>;</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [string, number]=[<span class="string">&quot;1&quot;</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>
<p>默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>
<p>或者，全部都采用手动赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = <span class="number">1</span>, Green = <span class="number">2</span>, Blue = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> colorName: string = Color[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colorName);  <span class="comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>
<h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: any[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&quot;free&quot;</span>];</span><br></pre></td></tr></table></figure>
<h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p>TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not much else we can assign to these variables!</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</p>
<h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。</p>
<p>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</p>
<p>下面是一些返回never类型的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">&quot;Something failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p>
<p>使用object类型，就可以更好的表示像Object.create这样的API。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | <span class="literal">null</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line">create(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;); <span class="comment">// OK</span></span><br><span class="line">create(<span class="literal">null</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">42</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="string">&quot;string&quot;</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="literal">false</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (&lt;string&gt;someValue).length;</span><br></pre></td></tr></table></figure>
<p>另一个为as语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (someValue <span class="keyword">as</span> string).length;</span><br></pre></td></tr></table></figure>
<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/12/29/TypeScript%E7%AC%94%E8%AE%B0/" data-id="ckmvs5u9e0000fsvxch4agtp2" class="article-share-link">Share</a>
      

      
    </footer>
  </div>
  
</article>


    
  

    
    <article id="post-class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/28/class/" class="article-date">
  <time datetime="2020-12-28T13:03:14.000Z" itemprop="datePublished">2020-12-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/28/class/">class</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>js语言中，生成实例对象的传统方法就是通过构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span> (<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.x = x;</span><br><span class="line">       <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`( <span class="subst">$&#123;<span class="built_in">this</span>.x&#125;</span> , <span class="subst">$&#123;<span class="built_in">this</span>.y&#125;</span> )`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">p.toString();</span><br><span class="line"><span class="comment">//&quot;(1,2)&quot;</span></span><br></pre></td></tr></table></figure>

<p>基本上，ES6的class可以看做知识一个语法糖，它的绝大部分功能，ES5都可以看到，新的class写法只是让对象原型的写法更加清晰，更像面向对象编程语法而已；上面的代码用class改写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x =x;</span><br><span class="line">        <span class="built_in">this</span>.y =y;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">        toString () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`( <span class="subst">$&#123;<span class="built_in">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="built_in">this</span>.y&#125;</span> )`</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       toValue () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x+<span class="built_in">this</span>.y;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">p.toString();</span><br><span class="line"><span class="comment">//&quot;(1,2)&quot;</span></span><br><span class="line">p.toValue();</span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>定义了一个Point类，他里面有个constructor方法，这就是构造方法；而this关键字则代表实例对象，也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法； Point类除了构造方法，还定义了一个toString方法，定义类的方法的时候，前面不需要加function这个关键字,直接将函数定义放进去就行了 ，另外，方法之间不需要逗号分隔；<br>构造函数的prototype属性，在ES6的类上继续存在，实际上，类的所有方法都定义在类的prototype属性上面；</p>
<p><strong>严格模式</strong><br>在类和模块的内部默认就是严格模式，所以不需要use strict指定运行模式,只要代码写在类或者模块之中，就只有严格模式可用；</p>
<p><strong>constructor方法</strong><br>constructor方法是类的默认方法，通过new 命令生成对象实例时，自动调用该方法，一个类必须有constructor方法，如果没有显示定义，一个空的constructor方法会被默认添加；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">     <span class="title">constructor</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor方法。</span></span><br></pre></td></tr></table></figure>
<p>constructor方法默认返回实例对象（即this）,完全可以指定返回另外一个对象；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">      <span class="title">constructor</span>  (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> Person</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//实例      instanceof 构造函数  用来判断实例是否是构造函数的实例</span></span><br></pre></td></tr></table></figure>
<p><strong>类的实例对象</strong><br>生成的实例对象的写法，与ES一样都是使用new命令，实例的属性除非显示定义在其本身（即定义在this对象上）,否则都是定义在原型上(即定义在class上)；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="title">constructor</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">           <span class="built_in">this</span>.x =x;</span><br><span class="line">            <span class="built_in">this</span>.y =y;</span><br><span class="line">          &#125; </span><br><span class="line">      toString () &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="built_in">this</span>.x&#125;</span>,<span class="subst">$&#123;<span class="built_in">this</span>.y&#125;</span>)`</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">point.toString();<span class="comment">//(1,2)</span></span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(<span class="string">&quot;x&quot;</span>); <span class="comment">//true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">&quot;y&quot;</span>); <span class="comment">//true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">&quot;toString&quot;</span>);<span class="comment">//fasle</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">&quot;toString&quot;</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>x和y都是实例对象point自身的属性（因为定义在this变量上）,所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上）,所以hasOwnProperty()方法返回false,这些都是ES5的行为保持一致；</p>
<p><strong>class表达式</strong><br>与函数一样，类也可以使用表达式的形式定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span></span>&#123;</span><br><span class="line">        getClassName () &#123;</span><br><span class="line">               <span class="keyword">return</span> Me.name ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用表达式定义了一个类，需要注意的是，这个类的名字MyClass而不是Me,Me只在Class的内部代码可用，这代当前类；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> inst  = <span class="keyword">new</span> MyClass();</span><br><span class="line">inst .getClassName();</span><br><span class="line"><span class="comment">//&quot;Me&quot;</span></span><br><span class="line">Me.name</span><br><span class="line"><span class="comment">//ReferenceError :Me is not defined</span></span><br></pre></td></tr></table></figure>
<p>Me只有在Class内部有定义；<br>如果类的内部没有用到的话，可以省略Me，可以改写成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    getClassName () &#123;</span><br><span class="line">               <span class="keyword">return</span>  ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用Class表达式，可以写出立即执行Class</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">      <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.name = name ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">person.sayName();</span><br><span class="line"><span class="comment">//&quot;张三&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>不存在变量提升</strong><br>这个和ES5完全不一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo();<span class="comment">//ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>()</span>;</span><br></pre></td></tr></table></figure>
<p>Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。<br><strong>this的指向</strong><br>类的方法内部如果含有this，他默认指向类的实例，但是，必须非常小心，一旦单独使用该方法，可能会报错；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">printName</span>(<span class="params">name = <span class="string">&#x27;there&#x27;</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params">text</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line">printName(); <span class="comment">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<p>printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。</p>
<p><strong>Class 的取值函数（getter）和存值函数（setter）</strong></p>
<p>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">prop</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line"><span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure>
<p>prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。<br><strong>Class 的静态方法</strong><br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure>
<p>Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。<br>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> bar () &#123;</span><br><span class="line">    <span class="built_in">this</span>.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> baz () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  baz () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。<br>父类的静态方法，可以被子类继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// &#x27;hello</span></span><br></pre></td></tr></table></figure>
<p>静态方法也是可以从super对象上调用的。</p>
<p><strong>Class 的静态属性和实例属性</strong><br>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//Foo类定义了一个静态属性prop,只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。</span></span><br></pre></td></tr></table></figure>
<p>类的实例属性</p>
<p>类的实例属性可以用等式，写入类的定义之中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  myProp = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myProp); <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//myProp就是MyClass的实例属性。在MyClass的实例上，以读取这个属性</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/12/28/class/" data-id="ckmvs5u9t0001fsvx2ren1yow" class="article-share-link">Share</a>
      

      
    </footer>
  </div>
  
</article>


    
  

    
    <article id="post-hook" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/27/hook/" class="article-date">
  <time datetime="2020-12-27T12:44:37.000Z" itemprop="datePublished">2020-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/27/hook/">hook</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是-React-Hooks"><a href="#什么是-React-Hooks" class="headerlink" title="什么是 React Hooks"></a>什么是 React Hooks</h2><p>React Hooks 是 React <code>16.7.0-alpha</code> 版本推出的新特性，想尝试的同学安装此版本即可。</p>
<p><strong>React Hooks 要解决的问题是状态共享</strong>，是继 <a href="https://link.zhihu.com/?target=https://reactjs.org/docs/render-props.html">render-props</a> 和 <a href="https://link.zhihu.com/?target=https://reactjs.org/docs/higher-order-components.html">higher-order components</a> 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。</p>
<p>这个状态指的是状态逻辑，所以称为<strong>状态逻辑复用</strong>会更恰当，因为只共享数据处理逻辑，不会共享数据本身。</p>
<blockquote>
<p>不久前精读分享过的一篇 <a href="https://link.zhihu.com/?target=https://github.com/dt-fe/weekly/blob/master/75.%E7%B2%BE%E8%AF%BB%E3%80%8AEpitath%20%E6%BA%90%E7%A0%81%20-%20renderProps%20%E6%96%B0%E7%94%A8%E6%B3%95%E3%80%8B.md">Epitath 源码 - renderProps 新用法</a> 就是解决 JSX 嵌套问题，有了 React Hooks 之后，这个问题就被官方正式解决了。</p>
</blockquote>
<p>为了更快理解 React Hooks 是什么，先看笔者引用的下面一段 renderProps 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Toggle initial=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">      &#123;<span class="function">(<span class="params">&#123; on, toggle &#125;</span>) =&gt;</span> (</span><br><span class="line">        &lt;Button type=<span class="string">&quot;primary&quot;</span> onClick=&#123;toggle&#125;&gt; Open Modal &lt;/Button&gt;</span><br><span class="line">        &lt;Modal visible=&#123;on&#125; onOk=&#123;toggle&#125; onCancel=&#123;toggle&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/Toggle&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>恰巧，React Hooks 解决的也是这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [open, setOpen] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Button type=<span class="string">&quot;primary&quot;</span> onClick=&#123;<span class="function">() =&gt;</span> setOpen(<span class="literal">true</span>)&#125;&gt;</span><br><span class="line">        Open Modal</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">      &lt;Modal</span><br><span class="line">        visible=&#123;open&#125;</span><br><span class="line">        onOk=&#123;<span class="function">() =&gt;</span> setOpen(<span class="literal">false</span>)&#125;</span><br><span class="line">        onCancel=&#123;<span class="function">() =&gt;</span> setOpen(<span class="literal">false</span>)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，React Hooks 就像一个内置的打平 renderProps 库，我们可以随时创建一个值，与修改这个值的方法。看上去像 function 形式的 setState，其实这等价于依赖注入，与使用 setState 相比，<strong>这个组件是没有状态的</strong>。</p>
<h2 id="React-Hooks-的特点"><a href="#React-Hooks-的特点" class="headerlink" title="React Hooks 的特点"></a>React Hooks 的特点</h2><p>React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性：</p>
<ol>
<li>多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。</li>
<li>Hooks 可以引用其他 Hooks。</li>
<li>更容易将组件的 UI 与状态分离。</li>
</ol>
<p>利用 useEffect 代替一些生命周期</p>
<p>在 useState 位置附近，可以使用 useEffect 处理副作用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Clean up the subscription</span></span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>useEffect</code> 的代码既会在初始化时候执行，也会在后续每次 rerender 时执行，而返回值在析构时执行。这个更多带来的是便利，对比一下 React 版 G2 调用流程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span>&lt;<span class="title">Props</span>, <span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">  private chart: G2.Chart = <span class="literal">null</span>;</span><br><span class="line">  private rootDomRef: React.ReactInstance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rootDom = ReactDOM.findDOMNode(<span class="built_in">this</span>.rootDomRef) <span class="keyword">as</span> HTMLDivElement;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.chart = <span class="keyword">new</span> G2.Chart(&#123;</span><br><span class="line">      container: <span class="built_in">document</span>.getElementById(<span class="string">&quot;chart&quot;</span>),</span><br><span class="line">      forceFit: <span class="literal">true</span>,</span><br><span class="line">      height: <span class="number">300</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.freshChart(<span class="built_in">this</span>.props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps: Props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.freshChart(nextProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.chart.destroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">freshChart</span>(<span class="params">props: Props</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">this</span>.chart.render();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;ref</span> =&gt;</span> (this.rootDomRef = ref)&#125; /&gt;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 React Hooks 可以这么做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = React.useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> chart: G2.Chart = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!chart) &#123;</span><br><span class="line">      chart = <span class="keyword">new</span> G2.Chart(&#123;</span><br><span class="line">        container: ReactDOM.findDOMNode(ref.current) <span class="keyword">as</span> HTMLDivElement,</span><br><span class="line">        width: <span class="number">500</span>,</span><br><span class="line">        height: <span class="number">500</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    chart.render();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> chart.destroy();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到将细碎的代码片段结合成了一个完整的代码块，更维护。</p>
<p>现在介绍了 <code>useState</code> <code>useContext</code> <code>useEffect</code> <code>useRef</code> 等常用 hooks，更多可以查阅：<a href="https://link.zhihu.com/?target=https://reactjs.org/docs/hooks-reference.html">内置 Hooks</a>，相信不久的未来，这些 API 又会成为一套新的前端规范。</p>
<h2 id="React-Hooks-将带来什么变化"><a href="#React-Hooks-将带来什么变化" class="headerlink" title="React Hooks 将带来什么变化"></a>React Hooks 将带来什么变化</h2><h2 id="Hooks-带来的约定"><a href="#Hooks-带来的约定" class="headerlink" title="Hooks 带来的约定"></a>Hooks 带来的约定</h2><p>Hook 函数必须以 “use” 命名开头，因为这样才方便 eslint 做检查，防止用 condition 判断包裹 useHook 语句。</p>
<p>为什么不能用 condition 包裹 useHook 语句，详情可以见 <a href="https://link.zhihu.com/?target=https://reactjs.org/docs/hooks-rules.html%23explanation">官方文档</a>，这里简单介绍一下。</p>
<p>React Hooks 并不是通过 Proxy 或者 getters 实现的（具体可以看这篇文章 <a href="https://link.zhihu.com/?target=https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">React hooks: not magic, just arrays</a>），而是通过数组实现的，每次 <code>useState</code> 都会改变下标，如果 <code>useState</code>被包裹在 condition 中，那每次执行的下标就可能对不上，导致 <code>useState</code> 导出的 <code>setter</code> 更新错数据。</p>
<p>虽然有 <a href="https://link.zhihu.com/?target=https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a> 插件保驾护航，但这第一次将 “约定优先” 理念引入了 React 框架中，带来了前所未有的<strong>代码命名和顺序限制</strong>（函数命名遭到官方限制，JS 自由主义者也许会暴跳如雷），但带来的便利也是前所未有的（没有比 React Hooks 更好的状态共享方案了，约定带来提效，自由的代价就是回到 renderProps or HOC，各团队可以自行评估）。</p>
<p>笔者认为，React Hooks 的诞生，也许来自于这个灵感：“不如通过增加一些约定，彻底解决状态共享问题吧！”</p>
<blockquote>
<p>React 约定大于配置脚手架 <a href="https://link.zhihu.com/?target=https://github.com/zeit/next.js">nextjs</a> <a href="https://link.zhihu.com/?target=https://github.com/umijs/umi">umi</a> 以及笔者的 <a href="https://link.zhihu.com/?target=https://github.com/prijs/pri">pri</a> 都通过有 “约定路由” 的功能，大大降低了路由配置复杂度，<strong>那么 React Hooks 就像代码级别的约定</strong>，大大降低了代码复杂度。</p>
</blockquote>
<h2 id="状态与-UI-的界限会越来越清晰"><a href="#状态与-UI-的界限会越来越清晰" class="headerlink" title="状态与 UI 的界限会越来越清晰"></a>状态与 UI 的界限会越来越清晰</h2><p>因为 React Hooks 的特性，如果一个 Hook 不产生 UI，那么它可以永远被其他 Hook 封装，虽然允许有副作用，但是被包裹在 <code>useEffect</code> 里，总体来说还是挺函数式的。而 Hooks 要集中在 UI 函数顶部写，也很容易养成书写无状态 UI 组件的好习惯，践行 “状态与 UI 分开” 这个理念会更容易。</p>
<p>不过这个理念稍微有点蹩脚的地方，那就是 “状态” 到底是什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useCount();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道 <code>useCount</code> 算是无状态的，因为 React Hooks 本质就是 renderProps 或者 HOC 的另一种写法，换成 renderProps 就好理解了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Count&gt;&#123;<span class="function">(<span class="params">count, setCount</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;</span> <span class="attr">setCount</span>=<span class="string">&#123;setCount&#125;</span> /&gt;</span></span>&#125;&lt;/Count&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;props.count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 App 组件是无状态的，输出完全由输入（Props）决定。</p>
<p>那么有状态无 UI 的组件就是 <code>useCount</code> 了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> [count, setCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有状态的地方应该指 <code>useState(0)</code> 这句，不过这句和无状态 UI 组件 App 的 <code>useCount()</code> 很像，既然 React 把 <code>useCount</code> 成为自定义 Hook，那么 <code>useState</code> 就是官方 Hook，具有一样的定义，因此可以认为 <code>useCount</code> 是无状态的，<code>useState</code> 也是一层 renderProps，最终的状态其实是 <code>useState</code> 这个 React 内置的组件。</p>
<p>我们看 renderProps 嵌套的表达：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;UseState&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">count, setCount</span>) =&gt;</span> (</span><br><span class="line">    &lt;UseCount&gt;</span><br><span class="line">      &#123;<span class="string">&quot; &quot;</span>&#125;</span><br><span class="line">      &#123;<span class="comment">/**虽然是透传，但给 count 做了去重，不可谓没有作用 */</span>&#125;</span><br><span class="line">      &#123;<span class="function">(<span class="params">count, setCount</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;</span> <span class="attr">setCount</span>=<span class="string">&#123;setCount&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">    &lt;/UseCount&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/UseState&gt;</span><br></pre></td></tr></table></figure>
<p>能确定的是，App 一定有 UI，而上面两层父级组件一定没有 UI。为了最佳实践，我们尽量避免 App 自己维护状态，而其父级的 RenderProps 组件可以维护状态（也可以不维护状态，做个二传手）。因此可以考虑在 “有状态的组件没有渲染，有渲染的组件没有状态” 这句话后面加一句：没渲染的组件也可以没状态。</p>
<h2 id="React-Hooks-实践"><a href="#React-Hooks-实践" class="headerlink" title="React Hooks 实践"></a>React Hooks 实践</h2><p>通过上面的理解，你已经对 React Hooks 有了基本理解，也许你也看了 React Hooks 基本实现剖析（就是数组），但理解实现原理就可以用好了吗？学的是知识，而用的是技能，看别人的用法就像刷抖音一样（哇，饭还可以这样吃？），你总会有新的收获。</p>
<h2 id="DOM-副作用修改-监听"><a href="#DOM-副作用修改-监听" class="headerlink" title="DOM 副作用修改 / 监听"></a>DOM 副作用修改 / 监听</h2><p>做一个网页，总有一些看上去和组件关系不大的麻烦事，比如修改页面标题（切换页面记得改成默认标题）、监听页面大小变化（组件销毁记得取消监听）、断网时提示（一层层装饰器要堆成小山了）。而 React Hooks 特别擅长做这些事，造这种轮子，大小皆宜。</p>
<blockquote>
<p>由于 React Hooks 降低了高阶组件使用成本，那么一套生命周期才能完成的 “杂耍” 将变得非常简单。</p>
</blockquote>
<p>下面举几个例子：</p>
<h2 id="修改页面-title"><a href="#修改页面-title" class="headerlink" title="修改页面 title"></a>修改页面 title</h2><p>效果：在组件里调用 <code>useDocumentTitle</code> 函数即可设置页面标题，且切换页面时，页面标题重置为默认标题 “前端精读”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useDocumentTitle(<span class="string">&quot;个人中心&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>实现：直接用 <code>document.title</code> 赋值，不能再简单。在销毁时再次给一个默认标题即可，这个简单的函数可以抽象在项目工具函数里，每个页面组件都需要调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDocumentTitle</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="built_in">document</span>.title = title;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> (<span class="built_in">document</span>.title = <span class="string">&quot;前端精读&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    [title]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/lrnvnx866l">在线 Demo</a></p>
<h2 id="监听页面大小变化，网络是否断开"><a href="#监听页面大小变化，网络是否断开" class="headerlink" title="监听页面大小变化，网络是否断开"></a>监听页面大小变化，网络是否断开</h2><p>效果：在组件调用 <code>useWindowSize</code> 时，可以拿到页面大小，并且在浏览器缩放时自动触发组件更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> windowSize = useWindowSize();</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>页面高度：&#123;windowSize.innerWidth&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>实现：和标题思路基本一致，这次从 <code>window.innerHeight</code> 等 API 直接拿到页面宽高即可，注意此时可以用 <code>window.addEventListener(&#39;resize&#39;)</code> 监听页面大小变化，此时调用 <code>setValue</code>将会触发调用自身的 UI 组件 rerender，就是这么简单！</p>
<p>最后注意在销毁时，<code>removeEventListener</code> 注销监听。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    innerHeight: <span class="built_in">window</span>.innerHeight,</span><br><span class="line">    innerWidth: <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    outerHeight: <span class="built_in">window</span>.outerHeight,</span><br><span class="line">    outerWidth: <span class="built_in">window</span>.outerWidth</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useWindowSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [windowSize, setWindowSize] = useState(getSize());</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleResize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setWindowSize(getSize());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, handleResize);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">&quot;resize&quot;</span>, handleResize);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> windowSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/j2rz2mj83">在线 Demo</a></p>
<h2 id="动态注入-css"><a href="#动态注入-css" class="headerlink" title="动态注入 css"></a>动态注入 css</h2><p>效果：在页面注入一段 class，并且当组件销毁时，移除这个 class。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> className = useCss(&#123;</span><br><span class="line">  color: <span class="string">&quot;red&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span>Text.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>实现：可以看到，Hooks 方便的地方是在组件销毁时移除副作用，所以我们可以安心的利用 Hooks 做一些副作用。注入 css 自然不必说了，而销毁 css 只要找到注入的那段引用进行销毁即可，具体可以看这个 <a href="https://link.zhihu.com/?target=https://github.com/streamich/nano-css/blob/c21413ddbed233777886f7c9aa1375af8a221f7b/addon/pipe.js%23L51">代码片段</a>。</p>
<blockquote>
<p>DOM 副作用修改 / 监听场景有一些现成的库了，从名字上就能看出来用法：<a href="https://link.zhihu.com/?target=https://github.com/rehooks/document-visibility">document-visibility</a>、<a href="https://link.zhihu.com/?target=https://github.com/rehooks/network-status">network-status</a>、<a href="https://link.zhihu.com/?target=https://github.com/rehooks/online-status">online-status</a>、<a href="https://link.zhihu.com/?target=https://github.com/rehooks/window-scroll-position">window-scroll-position</a>、<a href="https://link.zhihu.com/?target=https://github.com/rehooks/window-size">window-size</a>、<a href="https://link.zhihu.com/?target=https://github.com/rehooks/document-title">document-title</a>。</p>
</blockquote>
<h2 id="组件辅助"><a href="#组件辅助" class="headerlink" title="组件辅助"></a>组件辅助</h2><p>Hooks 还可以增强组件能力，比如拿到并监听组件运行时宽高等。</p>
<h2 id="获取组件宽高"><a href="#获取组件宽高" class="headerlink" title="获取组件宽高"></a>获取组件宽高</h2><p>效果：通过调用 <code>useComponentSize</code> 拿到某个组件 ref 实例的宽高，并且在宽高变化时，rerender 并拿到最新的宽高。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = useRef(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">let</span> componentSize = useComponentSize(ref);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &#123;componentSize.width&#125;</span><br><span class="line">    &lt;textArea ref=&#123;ref&#125; /&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>实现：和 DOM 监听类似，这次换成了利用 <code>ResizeObserver</code> 对组件 ref 进行监听，同时在组件销毁时，销毁监听。</p>
<p>其本质还是监听一些副作用，但通过 ref 的传递，我们可以对组件粒度进行监听和操作了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  handleResize();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> resizeObserver = <span class="keyword">new</span> ResizeObserver(<span class="function">() =&gt;</span> handleResize());</span><br><span class="line">  resizeObserver.observe(ref.current);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resizeObserver.disconnect(ref.current);</span><br><span class="line">    resizeObserver = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/zqxp3l9yrm">在线 Demo</a>，对应组件 <a href="https://link.zhihu.com/?target=https://github.com/rehooks/component-size">component-size</a>。</p>
<h2 id="拿到组件-onChange-抛出的值"><a href="#拿到组件-onChange-抛出的值" class="headerlink" title="拿到组件 onChange 抛出的值"></a>拿到组件 onChange 抛出的值</h2><p>效果：通过 <code>useInputValue()</code> 拿到 Input 框当前用户输入的值，而不是手动监听 onChange 再腾一个 <code>otherInputValue</code> 和一个回调函数把这一堆逻辑写在无关的地方。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = useInputValue(<span class="string">&quot;Jamie&quot;</span>);</span><br><span class="line"><span class="comment">// name = &#123; value: &#x27;Jamie&#x27;, onChange: [Function] &#125;</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...name</span>&#125; /&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看到，这样不仅没有占用组件自己的 state，也不需要手写 onChange 回调函数进行处理，这些处理都压缩成了一行 use hook。</p>
<p>实现：读到这里应该大致可以猜到了，利用 <code>useState</code> 存储组件的值，并抛出 <code>value</code> 与 <code>onChange</code>，监听 <code>onChange</code> 并通过 <code>setValue</code> 修改 <code>value</code>, 就可以在每次 <code>onChange</code> 时触发调用组件的 rerender 了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useInputValue</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [value, setValue] = useState(initialValue);</span><br><span class="line">  <span class="keyword">let</span> onChange = useCallback(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    setValue(event.currentTarget.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value,</span><br><span class="line">    onChange</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，我们对组件增强时，<strong>组件的回调一般不需要销毁监听，而且仅需监听一次，这与 DOM 监听不同</strong>，因此大部分场景，我们需要利用 <code>useCallback</code> 包裹，并传一个空数组，来保证永远只监听一次，而且不需要在组件销毁时注销这个 callback。</p>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/0xlk250l5l">在线 Demo</a>，对应组件 <a href="https://link.zhihu.com/?target=https://github.com/rehooks/input-value">input-value</a>。</p>
<h2 id="做动画"><a href="#做动画" class="headerlink" title="做动画"></a>做动画</h2><p>利用 React Hooks 做动画，一般是拿到一些具有弹性变化的值，我们可以将值赋给进度条之类的组件，这样其进度变化就符合某种动画曲线。</p>
<h2 id="在某个时间段内获取-0-1-之间的值"><a href="#在某个时间段内获取-0-1-之间的值" class="headerlink" title="在某个时间段内获取 0-1 之间的值"></a>在某个时间段内获取 0-1 之间的值</h2><p>这个是动画最基本的概念，某个时间内拿到一个线性增长的值。</p>
<p>效果：通过 <code>useRaf(t)</code> 拿到 t 毫秒内不断刷新的 0-1 之间的数字，期间组件会不断刷新，但刷新频率由 requestAnimationFrame 控制（不会卡顿 UI）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useRaf(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>实现：写起来比较冗长，这里简单描述一下。利用 <code>requestAnimationFrame</code> 在给定时间内给出 0-1 之间的值，那每次刷新时，只要判断当前刷新的时间点占总时间的比例是多少，然后做分母，分子是 1 即可。</p>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/n745x9pyy4">在线 Demo</a>，对应组件 <a href="https://link.zhihu.com/?target=https://github.com/streamich/react-use/blob/master/docs/useRaf.md">use-raf</a>。</p>
<h2 id="弹性动画"><a href="#弹性动画" class="headerlink" title="弹性动画"></a>弹性动画</h2><p>效果：通过 <code>useSpring</code> 拿到动画值，组件以固定频率刷新，而这个动画值以弹性函数进行增减。</p>
<p>实际调用方式一般是，先通过 <code>useState</code> 拿到一个值，再通过动画函数包住这个值，这样组件就会从原本的刷新一次，变成刷新 N 次，拿到的值也随着动画函数的规则变化，最后这个值会稳定到最终的输入值（如例子中的 <code>50</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [target, setTarget] = useState(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">const</span> value = useSpring(target);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setTarget(100)&#125;&gt;&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>实现：为了实现动画效果，需要依赖 <code>rebound</code> 库，它可以实现将一个目标值拆解为符合弹性动画函数过程的功能，那我们需要利用 React Hooks 做的就是在第一次接收到目标值是，调用 <code>spring.setEndValue</code> 来触发动画事件，并在 <code>useEffect</code> 里做一次性监听，再值变时重新 <code>setValue</code> 即可。</p>
<p>最神奇的 <code>setTarget</code> 联动 <code>useSpring</code> 重新计算弹性动画部分，是通过 <code>useEffect</code> 第二个参数实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">useEffect(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (spring) &#123;</span><br><span class="line">      spring.setEndValue(targetValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  [targetValue]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>也就是当目标值变化后，才会进行新的一轮 rerender，所以 <code>useSpring</code> 并不需要监听调用处的 <code>setTarget</code>，它只需要监听 <code>target</code> 的变化即可，而巧妙利用 <code>useEffect</code> 的第二个参数可以事半功倍。</p>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/yq0moqo8mv">在线 Demo</a></p>
<h2 id="Tween-动画"><a href="#Tween-动画" class="headerlink" title="Tween 动画"></a>Tween 动画</h2><p>明白了弹性动画原理，Tween 动画就更简单了。</p>
<p>效果：通过 <code>useTween</code> 拿到一个从 0 变化到 1 的值，这个值的动画曲线是 <code>tween</code>。可以看到，由于取值范围是固定的，所以我们不需要给初始值了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useTween();</span><br></pre></td></tr></table></figure>
<p>实现：通过 <code>useRaf</code> 拿到一个线性增长的值（区间也是 0 ～ 1），再通过 <code>easing</code> 库将其映射到 0 ～ 1 到值即可。这里用到了 hook 调用 hook 的联动（通过 <code>useRaf</code> 驱动 <code>useTween</code>），还可以在其他地方举一反三。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn: Easing = easing[easingName];</span><br><span class="line"><span class="keyword">const</span> t = useRaf(ms, delay);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fn(t);</span><br></pre></td></tr></table></figure>
<h2 id="发请求"><a href="#发请求" class="headerlink" title="发请求"></a>发请求</h2><p>利用 Hooks，可以将任意请求 Promise 封装为带有标准状态的对象：loading、error、result。</p>
<h2 id="通用-Http-封装"><a href="#通用-Http-封装" class="headerlink" title="通用 Http 封装"></a>通用 Http 封装</h2><p>效果：通过 <code>useAsync</code> 将一个 Promise 拆解为 loading、error、result 三个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; loading, error, result &#125; = useAsync(fetchUser, [id]);</span><br></pre></td></tr></table></figure>
<p>实现：在 Promise 的初期设置 loading，结束后设置 result，如果出错则设置 error，这里可以将请求对象包装成 <code>useAsyncState</code> 来处理，这里就不放出来了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useAsync</span>(<span class="params">asyncFunction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> asyncState = useAsyncState(options);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = asyncFunction();</span><br><span class="line">    asyncState.setLoading();</span><br><span class="line">    promise.then(</span><br><span class="line">      result =&gt; asyncState.setResult(result);,</span><br><span class="line">      error =&gt; asyncState.setError(error);</span><br><span class="line">    );</span><br><span class="line">  &#125;, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码可以参考 <a href="https://link.zhihu.com/?target=https://github.com/slorber/react-async-hook/blob/master/src/index.js">react-async-hook</a>，这个功能建议仅了解原理，具体实现因为有一些边界情况需要考虑，比如组件 isMounted 后才能相应请求结果。</p>
<h2 id="Request-Service"><a href="#Request-Service" class="headerlink" title="Request Service"></a>Request Service</h2><p>业务层一般会抽象一个 <code>request service</code> 做统一取数的抽象（比如统一 url，或者可以统一换 socket 实现等等）。假如以前比较 low 的做法是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// setState: 改 isLoading state</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> fetchUser()</span><br><span class="line">    <span class="comment">// setState: 改 isLoading、error、data</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// setState: 改 isLoading、error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后来把请求放在 redux 里，通过 connect 注入的方式会稍微有些改观：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Connect(...)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  public <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.fetchUser()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this.props.userData.isLoading | error | data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后会发现还是 Hooks 简洁明了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; isLoading, error, data &#125; = useFetchUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>useFetchUser</code> 利用上面封装的 <code>useAsync</code> 可以很容易编写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchUser = <span class="function"><span class="params">id</span> =&gt;</span></span><br><span class="line">  fetch(<span class="string">`xxx`</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.status !== <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;bad status = &quot;</span> + result.status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.json();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFetchUser</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> asyncFetchUser = useAsync(fetchUser, id);</span><br><span class="line">  <span class="keyword">return</span> asyncUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="填表单"><a href="#填表单" class="headerlink" title="填表单"></a>填表单</h2><p>React Hooks 特别适合做表单，尤其是 <a href="https://link.zhihu.com/?target=https://ant.design/components/form-cn/">antd form</a> 如果支持 Hooks 版，那用起来会方便许多：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; getFieldDecorator &#125; = useAntdForm();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Form onSubmit=&#123;<span class="built_in">this</span>.handleSubmit&#125; className=<span class="string">&quot;login-form&quot;</span>&gt;</span><br><span class="line">      &lt;FormItem&gt;</span><br><span class="line">        &#123;getFieldDecorator(<span class="string">&quot;userName&quot;</span>, &#123;</span><br><span class="line">          rules: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&quot;Please input your username!&quot;</span> &#125;]</span><br><span class="line">        &#125;)(</span><br><span class="line">          &lt;Input</span><br><span class="line">            prefix=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &quot;<span class="attr">rgba</span>(<span class="attr">0</span>,<span class="attr">0</span>,<span class="attr">0</span>,<span class="attr">.25</span>)&quot; &#125;&#125; /&gt;</span></span>&#125;</span><br><span class="line">            placeholder=<span class="string">&quot;Username&quot;</span></span><br><span class="line">          /&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/FormItem&gt;</span><br><span class="line">      &lt;FormItem&gt;</span><br><span class="line">        &lt;Button type=<span class="string">&quot;primary&quot;</span> htmlType=<span class="string">&quot;submit&quot;</span> className=<span class="string">&quot;login-form-button&quot;</span>&gt;</span><br><span class="line">          Log <span class="keyword">in</span></span><br><span class="line">        &lt;/Button&gt;</span><br><span class="line">        Or &lt;a href=<span class="string">&quot;&quot;</span>&gt;register now!&lt;/a&gt;</span><br><span class="line">      &lt;/FormItem&gt;</span><br><span class="line">    &lt;/Form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过虽然如此，<code>getFieldDecorator</code> 还是基于 RenderProps 思路的，彻底的 Hooks 思路是利用之前说的 <strong>组件辅助方式，提供一个组件方法集，用解构方式传给组件</strong>。</p>
<h2 id="模拟生命周期"><a href="#模拟生命周期" class="headerlink" title="模拟生命周期"></a>模拟生命周期</h2><p>有的时候 React15 的 API 还是挺有用的，利用 React Hooks 几乎可以模拟出全套。</p>
<h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><p>效果：通过 <code>useMount</code> 拿到 mount 周期才执行的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useMount(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// quite similar to `componentDidMount`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实现：<code>componentDidMount</code> 等价于 <code>useEffect</code> 的回调（仅执行一次时），因此直接把回调函数抛出来即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> <span class="keyword">void</span> fn(), []);</span><br></pre></td></tr></table></figure>
<h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h2><p>效果：通过 <code>useUnmount</code> 拿到 unmount 周期才执行的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useUnmount(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// quite similar to `componentWillUnmount`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实现：<code>componentWillUnmount</code> 等价于 <code>useEffect</code> 的回调函数返回值（仅执行一次时），因此直接把回调函数返回值抛出来即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> fn, []);</span><br></pre></td></tr></table></figure>
<h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><p>效果：通过 <code>useUpdate</code> 拿到 didUpdate 周期才执行的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useUpdate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// quite similar to `componentDidUpdate`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实现：<code>componentDidUpdate</code> 等价于 <code>useMount</code> 的逻辑每次执行，除了初始化第一次。因此采用 mouting flag（判断初始状态）+ 不加限制参数确保每次 rerender 都会执行即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mounting = useRef(<span class="literal">true</span>);</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (mounting.current) &#123;</span><br><span class="line">    mounting.current = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Force-Update"><a href="#Force-Update" class="headerlink" title="Force Update"></a>Force Update</h2><p>效果：这个最有意思了，我希望拿到一个函数 <code>update</code>，每次调用就强制刷新当前组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> update = useUpdate();</span><br></pre></td></tr></table></figure>
<p>实现：我们知道 <code>useState</code> 下标为 1 的项是用来更新数据的，而且就算数据没有变化，调用了也会刷新组件，所以我们可以把返回一个没有修改数值的 <code>setValue</code>，这样它的功能就仅剩下刷新组件了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useUpdate = <span class="function">() =&gt;</span> useState(<span class="number">0</span>)[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于 <code>getSnapshotBeforeUpdate</code>, <code>getDerivedStateFromError</code>, <code>componentDidCatch</code> 目前 Hooks 是无法模拟的。</p>
</blockquote>
<h2 id="isMounted"><a href="#isMounted" class="headerlink" title="isMounted"></a>isMounted</h2><p>很久以前 React 是提供过这个 API 的，后来移除了，原因是可以通过 <code>componentWillMount</code> 和 <code>componentWillUnmount</code> 推导。自从有了 React Hooks，支持 isMount 简直是分分钟的事。</p>
<p>效果：通过 <code>useIsMounted</code> 拿到 <code>isMounted</code> 状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isMounted = useIsMounted();</span><br></pre></td></tr></table></figure>
<p>实现：看到这里的话，应该已经很熟悉这个套路了，<code>useEffect</code> 第一次调用时赋值为 true，组件销毁时返回 false，注意这里可以加第二个参数为空数组来优化性能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [isMount, setIsMount] = useState(<span class="literal">false</span>);</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isMount) &#123;</span><br><span class="line">    setIsMount(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> setIsMount(<span class="literal">false</span>);</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="keyword">return</span> isMount;</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/5zwr1l1o1n">在线 Demo</a></p>
<h2 id="存数据"><a href="#存数据" class="headerlink" title="存数据"></a>存数据</h2><p>上一篇提到过 React Hooks 内置的 <code>useReducer</code> 可以模拟 Redux 的 reducer 行为，那唯一需要补充的就是将数据持久化。我们考虑最小实现，也就是全局 Store + Provider 部分。</p>
<h2 id="全局-Store"><a href="#全局-Store" class="headerlink" title="全局 Store"></a>全局 Store</h2><p>效果：通过 <code>createStore</code> 创建一个全局 Store，再通过 <code>StoreProvider</code> 将 <code>store</code> 注入到子组件的 <code>context</code>中，最终通过两个 Hooks 进行获取与操作：<code>useStore</code> 与 <code>useAction</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line">  user: &#123;</span><br><span class="line">    name: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    setName: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> &#123;</span><br><span class="line">      state.name = payload;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;StoreProvider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;YourApp /&gt;</span><br><span class="line">  &lt;/StoreProvider&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">YourApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> userName = useStore(<span class="function"><span class="params">state</span> =&gt;</span> state.user.name);</span><br><span class="line">  <span class="keyword">const</span> setName = userAction(<span class="function"><span class="params">dispatch</span> =&gt;</span> dispatch.user.setName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现：这个例子的实现可以单独拎出一篇文章了，所以笔者从存数据的角度剖析一下 <code>StoreProvider</code> 的实现。</p>
<p>对，Hooks 并不解决 Provider 的问题，所以全局状态必须有 Provider，但这个 Provider 可以利用 React 内置的 <code>createContext</code> 简单搞定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> StoreContext = createContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StoreProvider = <span class="function">(<span class="params">&#123; children, store &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;StoreContext.Provider value=&#123;store&#125;&gt;&#123;children&#125;&lt;/StoreContext.Provider&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>剩下就是 <code>useStore</code> 怎么取到持久化 Store 的问题了，这里利用 <code>useContext</code> 和刚才创建的 Context 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = useContext(StoreContext);</span><br><span class="line"><span class="keyword">return</span> store;</span><br></pre></td></tr></table></figure>
<p>更多源码可以参考 <a href="https://link.zhihu.com/?target=https://github.com/ctrlplusb/easy-peasy">easy-peasy</a>，这个库基于 redux 编写，提供了一套 Hooks API。</p>
<h2 id="封装原有库"><a href="#封装原有库" class="headerlink" title="封装原有库"></a>封装原有库</h2><p>是不是 React Hooks 出现后，所有的库都要重写一次？当然不是，我们看看其他库如何做改造。</p>
<h2 id="RenderProps-to-Hooks"><a href="#RenderProps-to-Hooks" class="headerlink" title="RenderProps to Hooks"></a>RenderProps to Hooks</h2><p>这里拿 <a href="https://link.zhihu.com/?target=https://github.com/renatorib/react-powerplug">react-powerplug</a> 举例。</p>
<p>比如有一个 renderProps 库，希望改造成 Hooks 的用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Toggle &#125; <span class="keyword">from</span> <span class="string">&#x27;react-powerplug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Toggle initial=&#123;<span class="literal">true</span>&#125;&gt;</span><br><span class="line">      &#123;<span class="function">(<span class="params">&#123; on, toggle &#125;</span>) =&gt;</span> (</span><br><span class="line">        &lt;Checkbox checked=&#123;on&#125; onChange=&#123;toggle&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/Toggle&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">↓ ↓ ↓ ↓ ↓ ↓</span><br><span class="line"><span class="keyword">import</span> &#123; useToggle &#125; <span class="keyword">from</span> <span class="string">&#x27;react-powerhooks&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [on, toggle] = useToggle()</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Checkbox</span> <span class="attr">checked</span>=<span class="string">&#123;on&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;toggle&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：假如我是 <code>react-powerplug</code> 的维护者，怎么样最小成本支持 React Hook? 说实话这个没办法一步做到，但可以通过两步实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Toggle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这是 Toggle 的源码</span></span><br><span class="line">  <span class="comment">// balabalabala..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = wrap(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第一步：包 wrap</span></span><br><span class="line">  <span class="keyword">const</span> [on, toggle] = useRenderProps(Toggle); <span class="comment">// 第二步：包 useRenderProps</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实现：首先解释一下为什么要包两层，首先 Hooks 必须遵循 React 的规范，我们必须写一个 <code>useRenderProps</code> 函数以符合 Hooks 的格式，<strong>那问题是如何拿到 Toggle 给 render 的 <code>on</code> 与 <code>toggle</code>？</strong>正常方式应该拿不到，所以退而求其次，将 <code>useRenderProps</code> 拿到的 Toggle 传给 <code>wrap</code>，<strong>让</strong> <code>**wrap**</code> <strong>构造 RenderProps 执行环境拿到</strong> <code>**on**</code> <strong>与</strong> <code>**toggle**</code> <strong>后，调用<code>useRenderProps</code>**</strong>内部的** <code>**setArgs**</code> <strong>函数，让</strong> <code>**const [on, toggle] = useRenderProps(Toggle)**</code> <strong>实现曲线救国。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrappers = []; <span class="comment">// 全局存储 wrappers</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useRenderProps = <span class="function">(<span class="params">WrapperComponent, wrapperProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [args, setArgs] = useState([]);</span><br><span class="line">  <span class="keyword">const</span> ref = useRef(&#123;&#125;);</span><br><span class="line">  <span class="keyword">if</span> (!ref.current.initialized) &#123;</span><br><span class="line">    wrappers.push(&#123;</span><br><span class="line">      WrapperComponent,</span><br><span class="line">      wrapperProps,</span><br><span class="line">      setArgs</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ref.current.initialized = <span class="literal">true</span>;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> args; <span class="comment">// 通过下面 wrap 调用 setArgs 获取值。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于 <code>useRenderProps</code> 会先于 <code>wrap</code> 执行，所以 wrappers 会先拿到 Toggle，<code>wrap</code> 执行时直接调用 <code>wrappers.pop()</code> 即可拿到 Toggle 对象。然后构造出 RenderProps 的执行环境即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> wrap = <span class="function"><span class="params">FunctionComponent</span> =&gt;</span> <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> element = FunctionComponent(props);</span><br><span class="line">  <span class="keyword">const</span> ref = useRef(&#123; <span class="attr">wrapper</span>: wrappers.pop() &#125;); <span class="comment">// 拿到 useRenderProps 提供的 Toggle</span></span><br><span class="line">  <span class="keyword">const</span> &#123; WrapperComponent, wrapperProps &#125; = ref.current.wrapper;</span><br><span class="line">  <span class="keyword">return</span> createElement(WrapperComponent, wrapperProps, <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// WrapperComponent =&gt; Toggle，这一步是在构造 RenderProps 执行环境</span></span><br><span class="line">    <span class="keyword">if</span> (!ref.current.processed) &#123;</span><br><span class="line">      ref.current.wrapper.setArgs(args); <span class="comment">// 拿到 on、toggle 后，通过 setArgs 传给上面的 args。</span></span><br><span class="line">      ref.current.processed = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.current.processed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上实现方案参考 <a href="https://link.zhihu.com/?target=https://github.com/dai-shi/react-hooks-render-props">react-hooks-render-props</a>，有需求要可以拿过来直接用，不过实现思路可以参考，作者的脑洞挺大。</p>
<h2 id="Hooks-to-RenderProps"><a href="#Hooks-to-RenderProps" class="headerlink" title="Hooks to RenderProps"></a>Hooks to RenderProps</h2><p>好吧，如果希望 Hooks 支持 RenderProps，那一定是希望同时支持这两套语法。</p>
<p>效果：一套代码同时支持 Hooks 和 RenderProps。</p>
<p>实现：其实 Hooks 封装为 RenderProps 最方便，因此我们使用 Hooks 写核心的代码，假设我们写一个最简单的 <code>Toggle</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useToggle = <span class="function"><span class="params">initialValue</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [on, setOn] = useState(initialValue);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    on,</span><br><span class="line">    toggle: <span class="function">() =&gt;</span> setOn(!on)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/ppvrpnz80m">在线 Demo</a></p>
<p>然后通过 <code>render-props</code> 这个库可以轻松封装出 RenderProps 组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Toggle = <span class="function">(<span class="params">&#123; initialValue, children, render = children &#125;</span>) =&gt;</span></span><br><span class="line">  renderProps(render, useToggle(initialValue));</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=https://codesandbox.io/s/249n3n4r30">在线 Demo</a></p>
<p>其实 <code>renderProps</code> 这个组件的第二个参数，在 Class 形式 React 组件时，接收的是 <code>this.state</code>，现在我们改成 <code>useToggle</code> 返回的对象，也可以理解为 <code>state</code>，利用 Hooks 机制驱动 Toggle 组件 rerender，从而让子组件 rerender。</p>
<h2 id="封装原本对-setState-增强的库"><a href="#封装原本对-setState-增强的库" class="headerlink" title="封装原本对 setState 增强的库"></a>封装原本对 setState 增强的库</h2><p>Hooks 也特别适合封装原本就作用于 setState 的库，比如 <a href="https://link.zhihu.com/?target=https://github.com/mweststrate/immer">immer</a>。</p>
<p><code>useState</code> 虽然不是 <code>setState</code>，但却可以理解为控制高阶组件的 <code>setState</code>，我们完全可以封装一个自定义的 <code>useState</code>，然后内置对 <code>setState</code> 的优化。</p>
<p>比如 immer 的语法是通过 <code>produce</code> 包装，将 mutable 代码通过 Proxy 代理为 immutable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nextState = produce(baseState, <span class="function"><span class="params">draftState</span> =&gt;</span> &#123;</span><br><span class="line">  draftState.push(&#123; <span class="attr">todo</span>: <span class="string">&quot;Tweet about it&quot;</span> &#125;);</span><br><span class="line">  draftState[<span class="number">1</span>].done = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那这个 <code>produce</code> 就可以通过封装一个 <code>useImmer</code> 来隐藏掉：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useImmer</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [val, updateValue] = React.useState(initialValue);</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    val,</span><br><span class="line">    updater =&gt; &#123;</span><br><span class="line">      updateValue(produce(updater));</span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [value, setValue] = useImmer(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">value(<span class="function"><span class="params">obj</span> =&gt;</span> (obj.a = <span class="number">2</span>)); <span class="comment">// immutable</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>把 React Hooks 当作更便捷的 RenderProps 去用吧，虽然写法看上去是内部维护了一个状态，但其实等价于注入、Connect、HOC、或者 renderProps，那么如此一来，使用 renderProps 的门槛会大大降低，因为 Hooks 用起来实在是太方便了，我们可以抽象大量 Custom Hooks，让代码更加 FP，同时也不会增加嵌套层级。</p>
<p>转载自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50597236">https://zhuanlan.zhihu.com/p/50597236</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/12/27/hook/" data-id="ckmvs5uc30005fsvxc3pvf3t4" class="article-share-link">Share</a>
      

      
    </footer>
  </div>
  
</article>


    
  

    
    <article id="post-什么是BFC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/25/%E4%BB%80%E4%B9%88%E6%98%AFBFC/" class="article-date">
  <time datetime="2020-12-25T12:53:53.000Z" itemprop="datePublished">2020-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/25/%E4%BB%80%E4%B9%88%E6%98%AFBFC/">什么是BFC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="BFC-定义"><a href="#BFC-定义" class="headerlink" title="BFC 定义"></a>BFC 定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有</span><br><span class="line">Block-level box参与，它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</span><br></pre></td></tr></table></figure>
<p>在解释什么是BFC之前，我们需要先知道Box、Formatting Context的概念。</p>
<h3 id="Box：css布局的基本单位"><a href="#Box：css布局的基本单位" class="headerlink" title="Box：css布局的基本单位"></a>Box：css布局的基本单位</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：</span><br><span class="line"></span><br><span class="line">block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</span><br><span class="line">inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</span><br><span class="line">run-in box: css3 中才有</span><br></pre></td></tr></table></figure>
<h3 id="Formatting-Context"><a href="#Formatting-Context" class="headerlink" title="Formatting Context"></a>Formatting Context</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</span><br></pre></td></tr></table></figure>
<h3 id="BFC的布局规则"><a href="#BFC的布局规则" class="headerlink" title="BFC的布局规则"></a>BFC的布局规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">内部的Box会在垂直方向，一个接一个地放置。</span><br><span class="line"></span><br><span class="line">Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。</span><br><span class="line"></span><br><span class="line">每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</span><br><span class="line"></span><br><span class="line">BFC的区域不会与float box重叠。</span><br><span class="line"></span><br><span class="line">BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</span><br><span class="line"></span><br><span class="line">计算BFC的高度时，浮动元素也参与计算。</span><br></pre></td></tr></table></figure>
<h3 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、float的值不是none。</span><br><span class="line">2、position的值不是static或者relative。</span><br><span class="line">3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex</span><br><span class="line">4、overflow的值不是visible</span><br></pre></td></tr></table></figure>
<h3 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h3><h2 id="1-利用BFC避免margin重叠。"><a href="#1-利用BFC避免margin重叠。" class="headerlink" title="1.利用BFC避免margin重叠。"></a>1.利用BFC避免margin重叠。</h2><p>一起来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;防止margin重叠&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    p &#123;</span><br><span class="line">        color: #f55;</span><br><span class="line">        background: yellow;</span><br><span class="line">        width: 200px;</span><br><span class="line">        line-height: 100px;</span><br><span class="line">        text-align:center;</span><br><span class="line">        margin: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;看看我的 margin是多少&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;看看我的 margin是多少&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>页面生成的效果就是这样的：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4255951c1dbe4057a711fcd87a6dedbe~tplv-k3u1fbpfcp-watermark.image"><br>根据第二条，属于同一个BFC的两个相邻的Box会发生margin重叠，所以我们可以设置，两个不同的BFC，也就是我们可以让把第二个p用div包起来，然后激活它使其成为一个BFC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;防止margin重叠&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    p &#123;</span><br><span class="line">        color: #f55;</span><br><span class="line">        background: yellow;</span><br><span class="line">        width: 200px;</span><br><span class="line">        line-height: 100px;</span><br><span class="line">        text-align:center;</span><br><span class="line">        margin: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">    div&#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;看看我的 margin是多少&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;看看我的 margin是多少&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c0f8b4e1e804e42be47962e420f5651~tplv-k3u1fbpfcp-watermark.image"></p>
<h2 id="2-自适应两栏布局"><a href="#2-自适应两栏布局" class="headerlink" title="2.自适应两栏布局"></a>2.自适应两栏布局</h2><p>根据：</p>
<p>每个盒子的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    .left &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 150px;</span><br><span class="line">        float: left;</span><br><span class="line">        background: rgb(139, 214, 78);</span><br><span class="line">        text-align: center;</span><br><span class="line">        line-height: 150px;</span><br><span class="line">        font-size: 20px;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    .right &#123;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background: rgb(170, 54, 236);</span><br><span class="line">        text-align: center;</span><br><span class="line">        line-height: 300px;</span><br><span class="line">        font-size: 40px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;LEFT&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;RIGHT&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>页面：<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0274a377949f491ab8154b465c4f8755~tplv-k3u1fbpfcp-watermark.image"><br>又因为：</p>
<p>BFC的区域不会与float box重叠。<br>所以我们让right单独成为一个BFC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    .left &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 150px;</span><br><span class="line">        float: left;</span><br><span class="line">        background: rgb(139, 214, 78);</span><br><span class="line">        text-align: center;</span><br><span class="line">        line-height: 150px;</span><br><span class="line">        font-size: 20px;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    .right &#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background: rgb(170, 54, 236);</span><br><span class="line">        text-align: center;</span><br><span class="line">        line-height: 300px;</span><br><span class="line">        font-size: 40px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;LEFT&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;RIGHT&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>页面：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6793461b8e34f40878325a0a8aa91a8~tplv-k3u1fbpfcp-watermark.image"><br>right会自动的适应宽度，这时候就形成了一个两栏自适应的布局。</p>
<h2 id="3-清除浮动。"><a href="#3-清除浮动。" class="headerlink" title="3.清除浮动。"></a>3.清除浮动。</h2><p>当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清除浮动。</p>
<p>比如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;清除浮动&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .par &#123;</span><br><span class="line">        border: 5px solid rgb(91, 243, 30);</span><br><span class="line">        width: 300px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .child &#123;</span><br><span class="line">        border: 5px solid rgb(233, 250, 84);</span><br><span class="line">        width:100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;par&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>页面：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7c6b8400d0840a8b9f3fe8d6fe744f3~tplv-k3u1fbpfcp-watermark.image"><br>这个时候我们根据最后一条：</p>
<p>计算BFC的高度时，浮动元素也参与计算。<br>给父节点激活BFC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;清除浮动&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .par &#123;</span><br><span class="line">        border: 5px solid rgb(91, 243, 30);</span><br><span class="line">        width: 300px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .child &#123;</span><br><span class="line">        border: 5px solid rgb(233, 250, 84);</span><br><span class="line">        width:100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;par&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>页面：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c6ed100c0a6439bbdece3433db6b3c1~tplv-k3u1fbpfcp-watermark.image"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上例子都体现了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</span><br></pre></td></tr></table></figure>
<p>因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/12/25/%E4%BB%80%E4%B9%88%E6%98%AFBFC/" data-id="ckmvs5ua50004fsvx7pm58nkl" class="article-share-link">Share</a>
      

      
    </footer>
  </div>
  
</article>


    
  

    
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/25/hello-world/" class="article-date">
  <time datetime="2020-12-25T08:54:01.553Z" itemprop="datePublished">2020-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/25/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2020/12/25/hello-world/" data-id="ckmvs5u9w0002fsvx8im0d9x2" class="article-share-link">Share</a>
      

      
    </footer>
  </div>
  
</article>


    
  
  
</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 彭博<br>
      Theme <a href="https://github.com/henryhuang/oishi" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/jquery.scrollUp.min.js"></script>


<script src="/js/jquery.transform.js"></script>


<script src="/js/menu.js"></script>



<script src="/js/script.js"></script>


<script src="/js/scrollUp.js"></script>


  </div>
</body>
</html>